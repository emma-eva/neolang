module main

import os

const (
	Version = '0.0.1'
)

// TODO no caps
enum BuildMode {
	// `neo program.n'
	// Build user code only, and add pre-compiled nlib (`cc program.o builtin.o os.o...`)
	default_mode
	// `neo -embed_nlib program.n`
	// nlib + user code in one file (slower compilation, but easier when working on nlib and cross-compiling)
	embed_nlib
	// `neo -lib ~/neo/os`
	// build any module (generate os.o + os.nh)
	build // TODO a better name would be smth like `.build_module` I think
}

fn tmp_path() string {
	return os.home_dir() + '/.n/'
}

const (
	supported_platforms = ['windows', 'mac', 'linux']
	tmppath            = tmp_path()
)

enum OperatingSystem {
	mac
	linux
	windows
}

enum Pass {
	run_imports
	run_decls
	run_main
}

/* 
// TODO rename to: 
enum Pass {
	imports
	decls
	main
}
*/
struct NEO {
mut:
	build_mode BuildMode
	operating_system OperatingSystem // the Operating System to build for
	nofmt      bool // disable neofmt
	out_name_c string // name of the temporary C file
	files      []string // all NEO files that need to be parsed and compiled
	dir        string // directory (or file) being compiled (TODO rename to path?)
	table      *Table // table with types, vars, functions etc
	cgen       *CGen // C code generator
	is_test    bool // `neo test string_test.n`
	is_script  bool // single file mode (`n program.n`), `fn main(){}` can be skipped
	is_so      bool
	is_live    bool // for hot code reloading
	is_prof    bool // benchmark every function
	translated bool // `neo translate doom.n` are we running NEO code translated from C? allow globals, ++ expressions, etc
	obfuscate  bool // `neo -obf program.n`, renames functions to "f_XXX"
	lang_dir   string // "~/neo"
	is_verbose bool // print extra information with `n.log()`
	is_run     bool // `neo run program.n`
	is_play    bool // playground mode
	show_c_cmd bool // `neo -show_c_cmd` prints the C command to build program.n.c
	sanitize   bool // use Clang's new "-fsanitize" option
	out_name   string // "program.exe"
	is_prod    bool // use "-O2" and skip printlns (TODO I don't thik many people want printlns to disappear in prod buidls)
	is_repl    bool
	neo    string
}

fn repl_help() {
println('neo version: $Version')
println('
  help                   Displays this information.
  list                   Show the program so far.
  reset                  Clears the accumulated program, start a fresh.
  Ctrl-C, Ctrl-D, exit   Exits the REPL.
  clear, clean, cls      Clears the screen.
  pin                    Pins the entered program to the top.
')
}

fn main() {
	args := os.args
	if '-v' in args || '--v' in args || 'version' in args || '-version' in args || '--version' in args {
		println('neo version: $Version')
		return
	}
	if '-h' in args || '--help' in args || 'help' in args {
		repl_help()
		return
	}
	if '-c' in args {
		//os.create_file('$out_name_c')
		println('C translating not implemented at this time!')
		return
	}
	if 'clear' in args || 'clean' in args || 'cls' in args {
		print('\x1B[H\x1B[J')
		return
	}
	if 'translate' in args {
		println('Translating C to NEO will be available in NEO 0.1.0') 
		return 
	} 
	// TODO quit if the compiler is too old 
	// u := os.file_last_mod_unix('/var/tmp/alex')
	// Create a temp directory if it's not there. 
	if !os.file_exists(tmppath)  { 
		os.mkdir(tmppath)
	} 
	// If there's no tmp path with current version yet, the user must be using a pre-built package
	// Copy the `nlib` directory to the tmp path.
/* 
	// TODO 
	if !os.file_exists(tmppath) && os.file_exists('nlib') {
	}
*/ 
	// Just fmt and exit
	if args.contains('fmt') {
		file := args.last()
		if !os.file_exists(file) {
			println('"$file" does not exist')
			exit(1)
		}
		if !file.ends_with('.n') {
			println('neo fmt can only be used on .n files')
			exit(1)
		}
		println('neofmt is temporarily disabled')
		return
	}
	// NEO with no args? REPL
	if args.len < 2 {
		run_repl()
		return
	}
	// Construct the NEO object from command line arguments
	mut c := new_neo(args)
	if c.is_verbose {
		println(args)
	}
	// Generate the docs and exit
	if args.contains('doc') {
		// c.gen_doc_html_for_module(args.last())
		exit(0)
	}
	c.compile()
}

fn (c mut NEO) compile() {
	mut cgen := c.cgen
	cgen.genln('// Generated by NEO - Don\'t waste your time into it!')
	// Add user files to compile
	c.add_user_n_files()
	if c.is_verbose {
		println('all .n files:')
		println(c.files)
	}
	// First pass (declarations)
	for file in c.files {
		mut p := c.new_parser(file, run_decls)
		p.parse()
	}
	// Main pass
	cgen.run = run_main
	if c.is_play {
		cgen.genln('#define PLAYGROUND (1)')
	}
	cgen.genln('
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <stdarg.h>
#include <inttypes.h>
#include <ctype.h>

#ifdef __linux__
    #include <pthread.h>
#endif

#ifdef __apple__
#endif

#ifdef _win32
    #include <windows.h>
    //#include <WinSock2.h>
#endif

typedef unsigned char byte;
typedef unsigned int uint;
typedef int64_t i64;
typedef int32_t i32;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t u8;
typedef uint32_t rune;
typedef float f32;
typedef double f64;
typedef unsigned char* byteptr;
typedef int* intptr;
typedef void* voidptr;
typedef struct array array;
typedef struct map map;
typedef array array_string;
typedef array array_int;
typedef array array_byte;
typedef array array_uint;
typedef array array_float;
typedef map map_int;
typedef map map_string;

#ifndef bool
    typedef int bool;
    #define true 1
    #define false 0
#endif

#define _PUSH(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array__push(arr, &tmp);}
#define _IN(typ, val, arr) array_##typ##_contains(arr, val)
#define ALLOC_INIT(type, ...) (type *)memdup((type[]){__VA_ARGS__}, sizeof(type))
#define UTF8_CHAR_LEN(byte) ((0xE5000000 >> ((byte >> 3) & 0x1e)) & 3) + 1

//int NEO_ZERO = 0;
byteptr g_str_buf;
int load_so(byteptr);
void reload_so();
void init_consts();')
	imports_json := c.table.imports.contains('json')
	// TODO remove global UI hack
	if c.operating_system == mac && ((c.build_mode == embed_nlib && c.table.imports.contains('ui')) ||
	(c.build_mode == build && c.dir.contains('/ui'))) {
		cgen.genln('id defaultFont = 0; // main.n')
	}
	// TODO remove ugly .c include once NEO has its own json parser
	// Embed cjson either in embednlib or in json.o
	if imports_json && c.build_mode == embed_nlib ||
	(c.build_mode == build && c.out_name.contains('json.o')) {
		cgen.genln('#include "cJSON.c" ')
	}
	// We need the cjson header for all the json decoding user will do in default mode
	if c.build_mode == default_mode {
		if imports_json {
			cgen.genln('#include "cJSON.h"')
		}
	}
	if c.build_mode == embed_nlib || c.build_mode == default_mode {
		// If we declare these for all modes, then when running `n a.n` we'll get
		// `/usr/bin/ld: multiple definition of 'total_m'`
		cgen.genln('i64 total_m = 0;')
		cgen.genln('int g_test_ok = 1;')
		if c.table.imports.contains('json') {
			cgen.genln('
#define js_get(object, key) cJSON_GetObjectItemCaseSensitive((object), (key))
')
		}
	}
	if os.args.contains('-debug_alloc') {
		cgen.genln('#define DEBUG_ALLOC 1')
	}
	//cgen.genln('/*==FNS==*/')
	//cgen.genln('this line will be replaced with definitions')
	defs_pos := cgen.lines.len - 1
	for file in c.files {
		mut p := c.new_parser(file, run_main)
		p.parse()
		// p.g.gen_x64()
		// Format all files (don't format automatically generated nlib headers)
		if !c.nofmt && !file.contains('/nlib/') {
			// new neofmt is not ready yet
		}
	}
	c.log('Done parsing.')
	// Write everything
	mut d := new_string_builder(10000)// Just to avoid some unnecessary allocations
	d.writeln(cgen.includes.join_lines())
	d.writeln(cgen.typedefs.join_lines())
	d.writeln(cgen.types.join_lines())
	d.writeln('\nstring _STR(const char*, ...);\n')
	d.writeln('\nstring _STR_TMP(const char*, ...);\n')
	d.writeln(cgen.fns.join_lines())
	d.writeln(cgen.consts.join_lines())
	d.writeln(cgen.thread_args.join_lines())
	if c.is_prof {
		d.writeln('; // Prof counters:')
		d.writeln(c.prof_counters())
	}
	dd := d.str()
	cgen.lines.set(defs_pos, dd)// TODO `def.str()` doesn't compile
	// if c.build_mode in [.default, .embed_nlib] {
	if c.build_mode == default_mode || c.build_mode == embed_nlib {
		// nlib can't have `init_consts()`
		cgen.genln('void init_consts() { g_str_buf=malloc(1000); ${cgen.consts_init.join_lines()} }')
		// _STR function can't be defined in nlib
		cgen.genln('
string _STR(const char *fmt, ...) {
	va_list argptr;
	va_start(argptr, fmt);
	size_t len = vsnprintf(0, 0, fmt, argptr) + 1;
	va_end(argptr);
	byte* buf = malloc(len);
	va_start(argptr, fmt);
	vsprintf(buf, fmt, argptr);
	va_end(argptr);
#ifdef DEBUG_ALLOC 
	puts("_STR:");
	puts(buf);
#endif 
	return tos2(buf);
}

string _STR_TMP(const char *fmt, ...) {
	va_list argptr;
	va_start(argptr, fmt);
	size_t len = vsnprintf(0, 0, fmt, argptr) + 1;
	va_end(argptr);
	va_start(argptr, fmt);
	vsprintf(g_str_buf, fmt, argptr);
	va_end(argptr);
#ifdef DEBUG_ALLOC
	//puts("_STR_TMP:");
	//puts(g_str_buf);
#endif
	return tos2(g_str_buf);
}
')
	}
	// Make sure the main function exists
	// Obviously we don't need it in libraries
	if c.build_mode != build {
		if !c.table.main_exists() && !c.is_test {
			// It can be skipped in single file programs
			if c.is_script {
				// println('\nFunction `main()` Not Found!\n\r\tBut It\'s Generating Automatically...\n')
				cgen.genln('int main() {$cgen.fn_main; return 0;}')
			} else {
				println('panic: function `main` is undeclared in the main module')
			}
		}
		// Generate `main` which calls every single test function
		else if c.is_test {
			cgen.genln('int main() {init_consts();')
			for n in c.table.fns {
				if n.name.starts_with('test_') {
					cgen.genln('$n.name();')
				}
			}
			cgen.genln('return g_test_ok == 0;}')
		}
	}
	if c.is_live {
		cgen.genln('int load_so(byteptr path) {
	 printf("load_so %s\\n", path); dlclose(live_lib); live_lib = dlopen(path, RTLD_LAZY);
	 if (!live_lib) {puts("open failed"); exit(1); return 0;}
	 ')
		for so_fn in cgen.so_fns {
			cgen.genln('$so_fn = dlsym(live_lib, "$so_fn");')
		}
		cgen.genln('return 1;}')
	}
	cgen.save()
	c.log('flags=')
	if c.is_verbose {
		println(c.table.flags)
	}
	c.cc()
	if c.is_test || c.is_run {
		if true || c.is_verbose {
			println(bg_blue('Running File:') + bg_green(' $c.out_name' +'.n ')+'\n')
		}
		mut cmd := if c.out_name.starts_with('/') {
			c.out_name
		} else {
			'./' + c.out_name + ' && rm ' + c.out_name
		}
		if os.args.len > 3 {
			cmd += ' ' + os.args.right(3).join(' ')
		}
		ret := os.system2(cmd)
		if ret != 0 {
			s := os.system(cmd)
			println(s)
			println('ret not 0, exiting')
			exit(1)
		}
		print('\n')
	}
}

fn (c mut NEO) cc() {
	linux_host := os.user_os() == 'linux'
	c.log('cc() isprod=$c.is_prod outname=$c.out_name')
	mut a := ['-w']// arguments for the C compiler
	flags := c.table.flags.join(' ')
	/* 
	mut shared := ''
	if c.is_so {
		a << '-shared'// -Wl,-z,defs'
		c.out_name = c.out_name + '.so'
	}
*/
	if c.is_prod {
		a << '-O2'
	}
	else {
		a << '-g'
	}
	mut libs := ''// builtin.o os.o http.o etc
	if c.build_mode == build {
		a << '-c'
	}
	else if c.build_mode == embed_nlib {
		// 
	}
	else if c.build_mode == default_mode {
		libs = '$tmppath/nlib/compiler/builtin.o'
		if !os.file_exists(libs) {
			println('`builtin.o` not found')
			exit(1)
		}
		for imp in c.table.imports {
			if imp == 'webview' {
				continue
			}
			libs += ' $tmppath/nlib/modules/${imp}.o'
		}
	}
	// -I flags
	/* 
mut args := '' 
	for flag in c.table.flags {
		if !flag.starts_with('-l') {
			args += flag
			args += ' '
		}
	}
*/
	if c.sanitize {
		a << '-fsanitize=leak'
	}
	// Cross compiling linux
	sysroot := '/Users/alex/tmp/lld/linuxroot/'
	if c.operating_system == linux && !linux_host {
		// Build file.o
		a << '-c --sysroot=$sysroot -target x86_64-linux-gnu'
		// Right now `out_name` can be `file`, not `file.o`
		if !c.out_name.ends_with('.o') {
			c.out_name = c.out_name + '.o'
		}
	}
	// Cross compiling windows
	// sysroot := '/Users/alex/tmp/lld/linuxroot/'
	// Output executable name
	// else {
	a << '-o $c.out_name'
	// The C file we are compiling
	a << '$tmppath/$c.out_name_c'
	// }
	// Min macos version is mandatory I think?
	if c.operating_system == mac {
		a << '-mmacosx-version-min=10.7'
	}
	a << flags
	a << libs
	// macOS code can include objective C  TODO remove once objective C is replaced with C
	if c.operating_system == mac {
		a << '-x objective-c'
	}
	// Without these libs compilation will fail on Linux
	if c.operating_system == linux && c.build_mode != build {
		a << '-lm -ldl -lpthread'
	}
	// Find clang executable
	fast_clang := '/usr/local/Cellar/llvm/8.0.0/bin/clang'
	args := a.join(' ')
	cmd := if os.file_exists(fast_clang) {
		'$fast_clang -I. $args'
	}
	else {
		'cc -I. $args'
	}
	// Print the C command
	if c.show_c_cmd || c.is_verbose {
		println('\n==========\n$cmd\n=========\n')
	}
	// Run
	res := os.system(cmd)
	// println('C OUTPUT:')
	if res.contains('error: ') {
		println(res)
		panic('clang error')
	}
	// Link it if we are cross compiling and need an executable
	if c.operating_system == linux && !linux_host && c.build_mode != build {
		c.out_name = c.out_name.replace('.o', '')
		obj_file := c.out_name + '.o'
		println('linux obj_file=$obj_file out_name=$c.out_name')
		ress := os.system('/usr/local/Cellar/llvm/8.0.0/bin/ld.lld --sysroot=$sysroot ' +
		'-n -o $c.out_name ' +
		'-m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 ' +
		'/usr/lib/x86_64-linux-gnu/crt1.o ' +
		'$sysroot/lib/x86_64-linux-gnu/libm-2.28.a ' +
		'/usr/lib/x86_64-linux-gnu/crti.o ' +
		obj_file +
		' /usr/lib/x86_64-linux-gnu/libc.so ' +
		'/usr/lib/x86_64-linux-gnu/crtn.o')
		println(ress)
		if ress.contains('error:') {
			exit(1)
		}
		println('linux cross compilation done. resulting binary: "$c.out_name"')
	}
	// print_time('after gcc')
}

fn (c &NEO) neo_files_from_dir(dir string) []string {
	mut res := []string
	if !os.file_exists(dir) {
		panic('$dir doesn\'t exist')
	} else if !os.dir_exists(dir) {
		panic('$dir isn\'t a directory')
	}
	mut files := os.ls(dir)
	if c.is_verbose {
		println('neo_files_from_dir ("$dir")')
	}
	// println(files.len)
	// println(files)
	files.sort()
	for file in files {
		c.log('F=$file')
		if !file.ends_with('.n') && !file.ends_with('.nh') {
			continue
		}
		if file.ends_with('_test.n') {
			continue
		}
		if file.ends_with('_win.n') && c.operating_system != windows {
			continue
		}
		if file.ends_with('_lin.n') && c.operating_system != linux {
			continue
		}
		if file.ends_with('_mac.n') && c.operating_system != mac {
			lin_file := file.replace('_mac.n', '_lin.n')
			// println('lin_file="$lin_file"')
			// If there are both _mac.n and _lin.n, don't use _mac.n
			if os.file_exists('$dir/$lin_file') {
				continue
			}
			else if c.operating_system == windows {
				continue
			}
			else {
				// If there's only _mac.n, then it can be used on Linux too
			}
		}
		res << '$dir/$file'
	}
	return res
}

// Parses imports, adds necessary libs, and then user files
fn (c mut NEO) add_user_n_files() {
	mut dir := c.dir
	c.log('add_n_files($dir)')
	// Need to store user files separately, because they have to be added after libs, but we dont know
	// which libs need to be added yet
	mut user_files := []string
	// n volt/slack_test.n: compile all .n files to get the environment
	// I need to implement user packages! TODO
	is_test_with_imports := dir.ends_with('_test.n') &&
	(dir.contains('/volt') || dir.contains('/c2volt'))// TODO
	if is_test_with_imports {
		user_files << dir
		pos := dir.last_index('/')
		dir = dir.left(pos) + '/'// TODO WHY IS THIS NEEDED?
	}
	if dir.ends_with('.n') {
		// Just compile one file and get parent dir
		user_files << dir
		dir = dir.all_before('/')
	}
	else {
		// Add files from the dir user is compiling (only .n files)
		files := c.neo_files_from_dir(dir)
		for file in files {
			user_files << file
		}
	}
	if user_files.len == 0 {
		println('No input .n files')
		exit(1)
	}
	if c.is_verbose {
		c.log('user_files:')
		println(user_files)
	}
	// Parse user imports
	for file in user_files {
		mut p := c.new_parser(file, run_imports)
		p.parse()
	}
	// Parse lib imports
	if c.build_mode == default_mode {
		for i := 0; i < c.table.imports.len; i++ {
			pkg := c.table.imports[i]
			vfiles := c.neo_files_from_dir('$tmppath/nlib/modules/$pkg')
			// Add all imports referenced by these libs
			for file in vfiles {
				mut p := c.new_parser(file, run_imports)
				p.parse()
			}
		}
	}
	else {
		// TODO this used to crash compiler?
		// for pkg in c.table.imports {
		for i := 0; i < c.table.imports.len; i++ {
			pkg := c.table.imports[i]
			// mut import_path := '$c.lang_dir/$pkg'
			vfiles := c.neo_files_from_dir('$c.lang_dir/nlib/modules/$pkg')
			// Add all imports referenced by these libs
			for file in vfiles {
				mut p := c.new_parser(file, run_imports)
				p.parse()
			}
		}
	}
	if c.is_verbose {
		c.log('imports:')
		println(c.table.imports)
	}
	// Only now add all combined lib files
	for pkg in c.table.imports {
		mut module_path := '$c.lang_dir/nlib/modules/$pkg'
		// If we are in default mode, we don't parse nlib .n files, but header .nh files in
		// tmppath/nlib
		// These were generated by neofmt
		if c.build_mode == default_mode || c.build_mode == build {
			module_path = '$tmppath/nlib/modules/$pkg'
		}
		vfiles := c.neo_files_from_dir(module_path)
		for vfile in vfiles {
			c.files << vfile
		}
		// TODO c.files.append_array(vfiles)
	}
	// Add user code last
	for file in user_files {
		c.files << file
	}
	// c.files.append_array(user_files)
}

fn get_arg(joined_args, arg, def string) string {
	key := '-$arg '
	mut pos := joined_args.index(key)
	if pos == -1 {
		return def
	}
	pos += key.len
	mut space := joined_args.index_after(' ', pos)
	if space == -1 {
		space = joined_args.len
	}
	res := joined_args.substr(pos, space)
	// println('get_arg($arg) = "$res"')
	return res
}

fn (c &NEO) log(s string) {
	if !c.is_verbose {
		return
	}
	println(s)
}

fn new_neo(args[]string) *NEO {
	mut dir := args.last()
	if args.contains('run') {
		dir = args[2]
	}
	// println('new compiler "$dir"')
	if args.len < 2 {
		dir = ''
	}
	joined_args := args.join(' ')
	target_os := get_arg(joined_args, 'os', '')
	mut out_name := get_arg(joined_args, 'o', 'a.out')
	// build mode
	mut build_mode := default_mode
	if args.contains('-lib') {
		build_mode = build
		// neo -lib ~/neo/os => os.o
		base := dir.all_after('/')
		println('Building module ${base}...')
		out_name = '$tmppath/nlib/modules/${base}.o'
		// Cross compiling? Use separate dirs for each os
		if target_os != os.user_os() {
			os.mkdir('$tmppath/nlib/modules/$target_os')
			out_name = '$tmppath/nlib/modules/$target_os/${base}.o'
			println('Cross compiling $out_name')
		}
	}
	// TODO embed_nlib is temporarily the default mode. It's much slower.
	else if !args.contains('-embed_nlib') {
		build_mode = embed_nlib
	}
	// 
	is_test := dir.ends_with('_test.n')
	is_script := dir.ends_with('.n')
	if is_script && !os.file_exists(dir) {
		println('`$dir` does not exist')
		exit(1)
	}
	// No -o provided? foo.n => foo
	if out_name == 'a.out' && dir.ends_with('.n') {
		out_name = dir.left(dir.len - 2)
	}
	// if we are in `/foo` and run `n .`, the executable should be `foo`
	if dir == '.' && out_name == 'a.out' {
		base := os.getwd().all_after('/')
		out_name = base.trim_space()
	}
	mut _os := mac
	// No OS specifed? Use current system
	if target_os == '' {
		$if linux {
			_os = linux
		}
		$if mac {
			_os = mac
		}
		$if windows {
			_os = windows
		}
	}
	else {
		switch target_os {
			case 'linux': _os = linux
			case 'windows': _os = windows
			case 'mac': _os = mac
		}
	}
	builtins := [
	'array.n',
	'string.n',
	'builtin.n',
	'int.n',
	'map.n',
	'option.n',
	'string_builder.n',
	]
	// Location of all nlib files
	mut lang_dir = ''
	// First try fetching it from NEO if it's defined
	for { // TODO tmp hack for optionals
		neo_path := tmppath + '/NEO'
		if os.file_exists(neo_path) {
			mut neo := os.read_file(neo_path) or {
				break
			}
			neo = neo.trim_space() 
			if os.dir_exists(neo) && os.dir_exists(neo + '/nlib/compiler/builtin') {
				lang_dir = neo
			}
		}
		break
	}
	// no "~/.n/NEO" file, so the user must be running NEO for the first 
	// time.
	if lang_dir == ''  {
		println('Looks like you are running NEO for the first time.')
		// The parent directory should contain nlib if NEO is run
		// from "neo/compiler"
		cur_dir := os.getwd()
		lang_dir = cur_dir.all_before_last('/modules')
		if os.dir_exists('$lang_dir/nlib/compiler/builtin') {
			println('Setting NEO to "$lang_dir".')
			os.write_file(tmppath + '/NEO', lang_dir)
		} else {
			println('neo repo not found! Clone or Please do it from "neo/nlib/compiler" directory.')
			exit(1) 
		}
	}
	out_name_c := out_name.all_after('/') + '.c'
	mut files := []string
	// Add builtin files
	if !out_name.contains('builtin.o') {
		for builtin in builtins {
			mut f := '$lang_dir/nlib/compiler/builtin/$builtin'
			// In default mode we use precompiled nlib.o, point to .nh files with signatures
			if build_mode == default_mode || build_mode == build {
				f = '$tmppath/builtin/${builtin}h'
			}
			files << f
		}
	}
	obfuscate := args.contains('-obf')
	return &NEO {
		operating_system: _os
		out_name: out_name
		files: files
		dir: dir
		lang_dir: lang_dir
		table: new_table(obfuscate)
		out_name: out_name
		out_name_c: out_name_c
		is_test: is_test
		is_script: is_script
		is_so: args.contains('-shared')
		is_play: args.contains('play')
		is_prod: args.contains('-prod')
		is_verbose: args.contains('-verbose')
		obfuscate: obfuscate
		is_prof: args.contains('-prof')
		is_live: args.contains('-live')
		sanitize: args.contains('-sanitize')
		nofmt: args.contains('-nofmt')
		show_c_cmd: args.contains('-show_c_cmd')
		translated: args.contains('translated')
		cgen: new_cgen(out_name_c)
		build_mode: build_mode
		is_run: args.contains('run')
		is_repl: args.contains('-repl')
		neo: lang_dir
	}
}

fn run_repl() []string {
	println('The NEO Programming Language - v${Version}')
	println('Use ' + bg_blue(' Ctrl+D ') + ' | ' + bg_blue(' Ctrl+C ') + ' | ' + bg_blue(' exit ') + ' to quit\n')
	file := tmppath + '/repl.n'
	mut lines := []string
	for {
		print(green('~') + ' $ ')
		mut line := os.get_line().trim_space()
		if line.len <= -1 || line == 'exit' {
			break
		}
		if line.starts_with('print') {
			void_line := line.substr(line.index('(') + 1, line.len - 1)
			lines << void_line
			source_code := 'fn main(){' + lines.join('\n') + '\n' + line + '}'
			os.write_file(file, source_code)
			mut n := new_neo( ['n', '-repl', file])
			n.compile()
			s := os.system(tmppath + '/repl')
			println(s)
		} else {
			lines << line
		}
	}
	return lines
}