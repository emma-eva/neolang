module main

struct Var {
mut:
	typ             string
	name            string
	is_arg          bool
	is_const        bool
	is_import_const bool // TODO remove import consts entirely
	args            []Var // function args
	attr            string //  [json] etc
	is_mut          bool
	ptr             bool
	ref             bool
	parent_fn       string // Variables can only be defined in functions
	pkg             string // module where this var is stored  TODO rename to `mod`
	line_nr         int
	access_mod      AccessMod
	is_global       bool // __global (translated from C only)
	is_used         bool
	scope_level     int
}

struct Parser {
	file_path      string // "/home/user/hello.n"
	file_name      string // "hello.n"
mut:
	scanner        *Scanner
	// tokens         []Kind // TODO cache all tokens, right now they have to be scanned twice
	token_idx      int
	tok            Kind
	prev_tok       Kind
	prev_tok2      Kind // TODO remove these once the tokens are cached
	lit            string
	cgen           *CGen
	table          *Table
	run            Pass // TODO rename `run` to `pass`
	operating_system OperatingSystem
	pkg            string
	inside_const   bool
	expr_var       Var
	assigned_type  string
	tmp_cnt        int
	// TODO all these options are copy-pasted from the NEO struct. Create a Settings struct instead?
	is_test        bool
	is_script      bool
	is_live        bool
	is_so          bool
	is_prof        bool
	translated     bool
	is_prod        bool
	is_verbose     bool
	obfuscate      bool
	is_play        bool
	is_repl        bool
	builtin_pkg    bool
	build_mode     BuildMode
	nh_lines       []string
	inside_if_expr bool
	is_struct_init bool
	if_expr_cnt    int
	for_expr_cnt   int // to detect whether `continue` can be used
	ptr_cast       bool
	calling_c      bool
	cur_fn         *Fn
	returns        bool
	neo            string
}

const (
	empty_fn = &Fn { }
)

fn (c mut NEO) new_parser(path string, run Pass) Parser {
	c.log('new_parser("$path")')
	c.cgen.run = run
	mut p := Parser {
		file_path: path
		file_name: path.all_after('/')
		scanner: new_scanner(path)
		table: c.table
		cur_fn: empty_fn
		cgen: c.cgen
		is_test: c.is_test
		is_script: (c.is_script && path == c.dir)
		is_so: c.is_so
		operating_system: c.operating_system
		is_prof: c.is_prof
		is_prod: c.is_prod
		is_play: c.is_play
		translated: c.translated
		obfuscate: c.obfuscate
		is_verbose: c.is_verbose
		build_mode: c.build_mode
		is_repl: c.is_repl
		run: run
		neo: c.neo
	}
	p.next()
	return p
}

fn (p mut Parser) next() {
	p.prev_tok2 = p.prev_tok
	p.prev_tok = p.tok
	res := p.scanner.scan()
	p.tok = res.tok
	p.lit = res.lit
}

fn (p &Parser) log(s string) {
	if !p.is_verbose {
		return
	}
	println(s)
}

fn (p mut Parser) parse() {
	p.log('\nparse() run=$p.run file=$p.file_name tok=${p.strtok()}')// , "script_file=", script_file)
	// `module main` is not required if it's a single file program
	if p.is_script || p.is_test {
		p.pkg = 'main'
		// User may still specify `module main`
		if p.tok == keyword_module {
			p.next()
			p.fgen('module ')
			p.pkg = p.check_name()
		}
	}
	else {
		p.check(keyword_module)
		p.pkg = p.check_name()
	}
	p.fgenln('\n')
	p.builtin_pkg = p.pkg == 'builtin'
	// Import pass - the first and the smallest pass that only analyzes imports
	p.table.register_package(p.pkg)
	if p.run == run_imports {
		for p.tok == keyword_import && p.peek() != keyword_const {
			p.import_statement()
		}
		return
	}
	// Go through every top level token or throw a compilation error if a non-top level token is met
	for {
		switch p.tok {
		case keyword_import:
			if p.peek() == keyword_const {
				p.const_decl()
			}
			else {
				// TODO remove imported consts from the language
				p.import_statement()
			}
		case keyword_enum:
			p.next()
			if p.tok == token_name {
				p.fgen('enum ')
				name := p.check_name()
				p.fgen(' ')
				p.enum_decl(name)
			}
			// enum without a name, only allowed in code, translated from C
			// it's a very bad practice in C as well, but is used unfortunately (for example, by DOOM)
			// such fields are basically int consts
			else if p.translated {
				p.enum_decl('int')
			}
			else {
				p.check(token_name)
			}
		case keyword_pub:
			if p.peek() == keyword_fn {
				p.fn_decl()
			}
			// TODO public structs
		case keyword_fn:
			p.fn_decl()
		case keyword_type:
			p.type_decl()
		case keyword_struct, keyword_interface, keyword_union, left_sbr:// `[` can only mean an [attribute] before the struct definition
			p.struct_decl()
		case keyword_const:
			p.const_decl()
		case hash:
			// insert C code, TODO this is going to be removed ASAP
			// some libraries (like UI) still have lots of C code
			// #puts("hello");
			p.chash()
		case dollar:
			// $if, $else
			p.comp_time()
		case keyword_global:
			if !p.translated {
				p.error('__global is only allowed in translated code')
			}
			p.next()
			name := p.check_name()
			typ := p.get_type()
			p.register_global(name, typ)
			// p.genln(p.table.cgen_name_type_pair(name, typ))
			mut g := p.table.cgen_name_type_pair(name, typ)
			if p.tok == assign {
				p.next()
				// p.gen(' = ')
				g += ' = '
				p.cgen.start_tmp()
				p.bool_expression()
				// g += '<<< ' + p.cgen.end_tmp() + '>>>'
				g += p.cgen.end_tmp()
			}
			// p.genln('; // global')
			g += ('; // global')
			p.cgen.consts << g
		case eof:
			p.log('end of parse()')
			if true && !p.first_run() && p.fileis('test') {
				out := os.create('/var/tmp/fmt.n')
				out.appendln(p.scanner.fmt_out.str())
				out.close()
			}
			return
		default:
			// no `fn main`, add this "global" statement to cgen.fn_main
			if p.is_script && !p.is_test {
				if p.cur_fn.scope_level == 0 {
					// p.cur_fn.scope_level++
				}
				// println('is script')
				// p.print_tok() // it will output token when missing main() fn
				start := p.cgen.lines.len
				p.statement(true)
				end := p.cgen.lines.len
				lines := p.cgen.lines.slice(start, end)
				// p.cgen.fn_main << p.cgen.prev_line
				// println('fn line:')
				// println(p.cgen.fn_main + lines.join('\n'))
				p.cgen.fn_main = p.cgen.fn_main + lines.join('\n')
				p.cgen.cur_line = ''
				for i := start; i < end; i++ {
					// p.cgen.lines[p.cgen.lines.len - 1] = ''
					p.cgen.lines[i] = ''
				}
				// exit('')
			}
			else {
				p.error('unexpected token `${p.strtok()}`')
			}
		}
	}
}

fn (p mut Parser) import_statement() {
	p.check(keyword_import)
	// `import ()`
	if p.tok == left_par {
		p.check(left_par)
		for p.tok != right_par && p.tok != eof {
			pkg := p.lit.trim_space()
			p.next()
			if p.table.imports.contains(pkg) {
				continue
			}
			p.table.imports << pkg
			p.table.register_package(pkg)
		}
		p.check(right_par)
		return
	}
	// `import foo`
	if p.tok != token_name {
		p.error('bad import format')
	}
	pkg := p.lit.trim_space()
	p.next()
	p.fgenln(' ' + pkg)
	// Make sure there are no duplicate imports
	if p.table.imports.contains(pkg) {
		return
	}
	p.log('adding import $pkg')
	p.table.imports << pkg
	p.table.register_package(pkg)
}

fn (p mut Parser) const_decl() {
	is_import := p.tok == keyword_import
	p.inside_const = true
	if is_import {
		p.next()
	}
	p.check(keyword_const)
	p.fspace()
	p.check(left_par)
	p.fgenln('')
	p.scanner.fmt_indent++
	for p.tok == token_name {
		// `Age = 20`
		mut name := p.check_name()
		if p.is_play && ! (name[0] >= `A` && name[0] <= `Z`) {
			p.error('const name must be capitalized')
		}
		// Imported consts (like GL_TRIANGLES) dont need pkg prepended (gl__GL_TRIANGLES)
		if !is_import {
			name = p.prepend_pkg(name)
		}
		mut typ := 'int'
		if !is_import {
			p.check_space(assign)
			typ = p.expression()
		}
		if p.first_run() && !is_import && p.table.known_const(name) {
			p.error('redefinition of `$name`')
		}
		p.table.register_const(name, typ, p.pkg, is_import)
		if p.run == run_main && !is_import {
			// TODO hack
			// cur_line has const's value right now. if it's just a number, then optimize generation:
			// output a #define so that we don't pollute the binary with unnecessary global vars
			if is_compile_time_const(p.cgen.cur_line) {
				p.cgen.consts << '#define $name $p.cgen.cur_line'
				p.cgen.cur_line = ''
				p.fgenln('')
				continue
			}
			if typ.starts_with('[') {
				p.cgen.consts << p.table.cgen_name_type_pair(name, typ) +
				' = $p.cgen.cur_line;'
			}
			else {
				p.cgen.consts << p.table.cgen_name_type_pair(name, typ) + ';'
				p.cgen.consts_init << '$name = $p.cgen.cur_line;'
			}
			p.cgen.cur_line = ''
		}
		p.fgenln('')
	}
	p.scanner.fmt_indent--
	p.check(right_par)
	p.fgenln('\n')
	p.inside_const = false
}

// `type myint int`
// `type onclickfn fn(voidptr) int`
fn (p mut Parser) type_decl() {
	p.check(keyword_type)
	name := p.check_name()
	parent := p.get_type()
	nt_pair := p.table.cgen_name_type_pair(name, parent)
	// TODO dirty C typedef hacks for DOOM
	// Unknown type probably means it's a struct, and it's used before the struct is defined,
	// so specify "struct"
	_struct := if !parent.contains('[') && !parent.starts_with('fn ') && !p.table.known_type(parent){'struct'} else { ''}
	p.gen_typedef('typedef $_struct $nt_pair; // type alias name="$name" parent="$parent"')
	p.table.register_type_with_parent(name, parent)
}

// also unions and interfaces
fn (p mut Parser) struct_decl() {
	// Attribute before type?
	mut objc_parent := ''
	mut is_objc := false// NEO can generate Objective C for integration with Cocoa
	// [attr]
	if p.tok == left_sbr {
		p.check(left_sbr)
		// `[interface:ParentInterface]`
		is_objc = p.tok == keyword_interface
		p.next()
		if is_objc {
			p.check(colon)
			objc_parent = p.check_name()
		}
		p.check(right_sbr)
	}
	is_interface := p.tok == keyword_interface
	is_union := p.tok == keyword_union
	is_struct := p.tok == keyword_struct
	p.fgen(p.tok.str() + ' ')
	// Get type name
	p.next()
	mut name := p.check_name()
	if name.contains('_') && !p.translated {
		p.error('type names cannot contain `_`')
	}
	if is_interface && !name.ends_with('er') {
		p.error('interface names temporarily have to end with `er` (e.g. `Speaker`, `Reader`)')
	}
	is_c := name == 'C' && p.tok == sdot
	if is_c {
		p.check(sdot)
		name = p.check_name()
	}
	// Specify full type name
	if !is_c && !p.builtin_pkg && p.pkg != 'main' {
		name = p.prepend_pkg(name)
	}
	if p.run == run_decls && p.table.known_type(name) {
		p.error('`$name` redeclared')
	}
	// Generate type definitions
	if is_objc {
		p.gen_type('@interface $name : $objc_parent { @public')
	}
	else {
		// type alias is generated later
		if !is_c {
			kind := if is_union{'union'} else { 'struct'}
			p.gen_typedef('typedef $kind $name $name;')
			p.gen_type('$kind $name {')
		}
	}
	// NEO used to have 'type Foo struct', many Go users might use this syntax
	if p.tok == keyword_struct {
		p.error('use `struct $name {` instead of `type $name struct {`')
	}
	// Register the type
	mut typ := p.table.find_type(name)
	mut is_ph := false
	if typ.is_placeholder {
		is_ph = true
		typ.name = name
		typ.pkg = p.pkg
		typ.is_c = is_c
		typ.is_placeholder = false
	}
	else {
		typ = &Type {
			name: name
			pkg: p.pkg
			is_c: is_c
			is_interface: is_interface
		}
	}
	// Struct `C.Foo` declaration, no body
	// println('EEEE $is_c $is_struct')
	if is_c && is_struct && p.tok != left_cbr {
		// println('skipping struct header $name')
		p.table.register_type2(typ)
		return
	}
	p.fgen(' ')
	p.check(left_cbr)
	// Struct fields
	mut is_pub := false
	mut is_mut := false
	mut names := []string// to avoid dup names TODO alloc perf
	// mut is_mut_mut := false
	for p.tok != right_cbr {
		if p.tok == keyword_pub {
			if is_pub {
				p.error('structs can only have one `pub:`, all public fields have to be grouped')
			}
			is_pub = true
			p.scanner.fmt_indent--
			p.check(keyword_pub)
			if p.tok != keyword_mut {
				p.check(colon)
			}
			p.scanner.fmt_indent++
			p.fgenln('')
		}
		if p.tok == keyword_mut {
			if is_mut {
				p.error('structs can only have one `mut:`, all private mutable fields have to be grouped')
			}
			is_mut = true
			p.scanner.fmt_indent--
			p.check(keyword_mut)
			if p.tok != keyword_mut {
				p.check(colon)
			}
			p.scanner.fmt_indent++
			p.fgenln('')
		}
		// if is_pub {
		// }
		// (mut) user *User
		// if p.tok == plus {
		// p.next()
		// }
		// Check dups
		field_name := p.check_name()
		if field_name in names {
			p.error('duplicate field `$field_name`')
		}
		names << field_name
		// We are in an interface?
		// `run() string` => run is a method, not a struct field
		if is_interface {
			mut interface_method := &Fn {
				name: field_name
				is_interface: true
				is_method: true
				receiver_typ: name
			}
			println('is interface. field=$field_name run=$p.run')
			p.fn_args(mut interface_method)
			p.fspace()
			interface_method.typ = p.get_type()// method return type
			typ.add_method(interface_method)
			p.fgenln('')
			continue
		}
		// `pub` access mod
		access_mod := if is_pub{public} else { private}
		p.fgen(' ')
		field_type := p.get_type()
		is_atomic := p.tok == keyword_atomic
		if is_atomic {
			p.next()
			p.gen_type('_Atomic ')
		}
		if !is_c {
			p.gen_type(p.table.cgen_name_type_pair(field_name, field_type) + ';')
		}
		// [ATTR]
		mut attr := ''
		if p.tok == left_sbr {
			p.next()
			attr = p.check_name()
			p.check(right_sbr)
		}
		typ.add_field(field_name, field_type, is_mut, attr, access_mod)
		p.fgenln('')
	}
	if !is_ph && p.first_run() {
		p.table.register_type2(typ)
	}
	p.check(right_cbr)
	if !is_c {
		p.gen_type('}; ')
	}
	if is_objc {
		p.gen_type('@end')
	}
	p.fgenln('\n')
}

fn (p mut Parser) enum_decl(_enum_name string) {
	mut enum_name := _enum_name
	// Specify full type name
	if !p.builtin_pkg && p.pkg != 'main' {
		enum_name = p.prepend_pkg(enum_name)
	}
	p.table.register_type2(&Type {
		name: enum_name
		pkg: p.pkg
		parent: 'int'
		is_enum: true
	})
	// Skip empty enums
	if enum_name != 'int' {
		p.cgen.typedefs << 'typedef int $enum_name ;\n'
	}
	p.check(left_cbr)
	mut val := 0
	for p.tok == token_name {
		field := p.check_name()
		// name := '${p.pkg}__${enum_name}_$field'
		// name := '${enum_name}_$field'
		name := '$field'
		p.fgenln('')
		if p.run == run_main {
			p.cgen.consts << '#define $name $val \n'
		}
		if p.tok == comma {
			p.next()
		}
		p.table.register_const(name, enum_name, p.pkg, false)
		val++
	}
	p.check(right_cbr)
	p.fgenln('\n')
}

// check_name checks for a name token and returns its literal
fn (p mut Parser) check_name() string {
	name := p.lit
	p.check(token_name)
	return name
}

fn (p mut Parser) check_string() string {
	s := p.lit
	p.check(token_string)
	return s
}

fn (p &Parser) strtok() string {
	if p.tok == token_name {
		return p.lit
	}
	if p.tok == token_string {
		return '"$p.lit"'
	}
	res := p.tok.str()
	if res == '' {
		n := int(p.tok)
		return n.str()
	}
	return res
}

// same as check(), but addes a space to the formatter output
// TODO bad name
fn (p mut Parser) check_space(expected Kind) {
	p.fspace()
	p.check(expected)
	p.fspace()
}

fn (p mut Parser) check(expected Kind) {
	if p.tok != expected {
		println('check()')
		mut s := 'expected `${expected.str()}` but got `${p.strtok()}`'
		p.next()
		println('next token = `${p.strtok()}`')
		print_backtrace()
		p.error(s)
	}
	if expected == right_cbr {
		p.scanner.fmt_indent--
	}
	p.fgen(p.strtok())
	// neofmt: increase indentation on `{` unless it's `{}`
	if expected == left_cbr && p.scanner.text[p.scanner.pos + 1] != `}` {
		p.fgenln('')
		p.scanner.fmt_indent++
	}
	p.next()
}

fn (p mut Parser) error(s string) {
	// Dump all vars and types for debugging
	if false {
		file_types := os.create('$tmppath/types')
		file_vars := os.create('$tmppath/vars')
		file_types.close()
		file_vars.close()
	}
	if !p.is_repl {
		println('pass=$p.run fn=`$p.cur_fn.name`')
	}
	p.cgen.save()
	p.scanner.error(s.replace('array_', '[]').replace('__', '.'))
}

fn (p &Parser) first_run() bool {
	return p.run == run_decls
}

// TODO return Type instead of string?
fn (p mut Parser) get_type() string {
	debug := p.fileis('fn_test') && false
	mut mult := false
	mut nr_muls := 0
	mut typ = ''
	// fn type
	if p.tok == keyword_fn {
		if debug {
			println('\nget_type() GOT FN TYP line=$p.scanner.line_nr')
		}
		mut f := Fn{name: '_', pkg: p.pkg}
		p.next()
		line_nr := p.scanner.line_nr
		p.fn_args(mut f)
		// Same line, it's a return type
		if p.scanner.line_nr == line_nr {
			if debug {
				println('same line getting type')
			}
			f.typ = p.get_type()
			// println('fn return typ=$f.typ')
		}
		else {
			f.typ = 'void'
		}
		// Register anon fn type
		fn_typ := Type {
			name: f.typ_str()// 'fn (int, int) string'
			pkg: p.pkg
			func: f
		}
		p.table.register_type2(fn_typ)
		return f.typ_str()
	}
	// arrays ([]int)
	mut is_arr := false
	mut is_arr2 := false// [][]int TODO remove this and allow unlimited levels of arrays
	is_question := p.tok == question
	if is_question {
		p.check(question)
	}
	if p.tok == left_sbr {
		p.check(left_sbr)
		// [10]int
		if p.tok == token_int {
			typ = '[$p.lit]'
			p.next()
		}
		else {
			is_arr = true
		}
		p.check(right_sbr)
		// [10][3]int
		if p.tok == left_sbr {
			p.next()
			if p.tok == token_int {
				typ += '[$p.lit]'
				p.check(token_int)
			}
			else {
				is_arr2 = true
			}
			p.check(right_sbr)
		}
	}
	for p.tok == mul {
		mult = true
		nr_muls++
		p.next()
	}
	if p.tok == amp {
		mult = true
		nr_muls++
		p.next()
	}
	typ += p.lit
	if !p.is_struct_init {
		// Otherwise we get `foo := FooFoo{` because `Foo` was already generated in name_expr()
		p.fgen(p.lit)
	}
	// C.Struct import
	if p.lit == 'C' && p.peek() == sdot {
		p.next()
		p.check(sdot)
		typ = p.lit
	}
	else {
		// Package specified? (e.g. gx.Image)
		if p.peek() == sdot {
			p.next()
			p.check(sdot)
			typ += '__$p.lit'
		}
		mut t := p.table.find_type(typ)
		// "typ" not found? try "pkg__typ"
		if t.name == '' && !p.builtin_pkg {
			// && !p.first_run() {
			if !typ.contains('array_') && p.pkg != 'main' && !typ.contains('__') {
				typ = p.prepend_pkg(typ)
			}
			t = p.table.find_type(typ)
			if t.name == '' && !p.translated && !p.first_run() && !typ.starts_with('[') {
				println('get_type() bad type')
				// println('all registered types:')
				// for q in p.table.types {
				// println(q.name)
				// }
				p.error('unknown type `$typ`')
			}
		}
	}
	if typ == 'void' {
		p.error('unknown type `$typ`')
	}
	if mult {
		typ += repeat_char(`*`, nr_muls)
	}
	// Register an []array type
	if is_arr2 {
		typ = 'array_array_$typ'
		p.register_array(typ)
	}
	else if is_arr {
		typ = 'array_$typ'
		// p.log('ARR TYPE="$typ" run=$p.run')
		// We come across "[]User" etc ?
		p.register_array(typ)
	}
	p.next()
	if p.tok == question || is_question {
		typ = 'Option_$typ'
		p.table.register_type_with_parent(typ, 'Option')
		if p.tok == question {
			p.next()
		}
	}
	// Because the code uses * to see if it's a pointer
	if typ == 'byteptr' {
		return 'byte*'
	}
	if typ == 'voidptr' {
		//if !p.builtin_pkg && p.pkg != 'os' && p.pkg != 'gx' && p.pkg != 'gg' && !p.translated {
			//p.error('voidptr can only be used in unsafe code')
		//}
		return 'void*'
	}
	if typ.last_index('__') > typ.index('__') {
		p.error('2 __ in gettype(): typ="$typ"')
	}
	return typ
}

fn (p &Parser) print_tok() {
	if p.tok == token_name {
		println(p.lit)
		return
	}
	if p.tok == token_string {
		println('"$p.lit"')
		return
	}
	println(p.tok.str())
}

// statements() returns the type of the last statement
fn (p mut Parser) statements() string {
	p.log('statements()')
	typ := p.statements_no_curly_end()
	if !p.inside_if_expr {
		p.genln('}')
	}
	if p.fileis('if_expr') {
		println('statements() ret=$typ line=$p.scanner.line_nr')
	}
	return typ
}

fn (p mut Parser) statements_no_curly_end() string {
	p.cur_fn.open_scope()
	if !p.inside_if_expr {
		p.genln('')
	}
	mut i := 0
	mut last_st_typ := ''
	for p.tok != right_cbr && p.tok != eof && p.tok != keyword_case && p.tok != keyword_default {
		// println(p.tok.str())
		// p.print_tok()
		last_st_typ = p.statement(true)
		// println('last st typ=$last_st_typ')
		if !p.inside_if_expr {
			p.genln('')// // end st tok= ${p.strtok()}')
			p.fgenln('')
		}
		i++
		if i > 50000 {
			p.cgen.save()
			p.error('more than 50 000 statements in function `$p.cur_fn.name`')
		}
	}
	if p.tok != keyword_case && p.tok != keyword_default {
		// p.next()
		p.check(right_cbr)
	}
	else {
		// p.check(right_cbr)
	}
	p.scanner.fmt_indent--
	// println('close scope line=$p.scanner.line_nr')
	p.cur_fn.close_scope()
	return last_st_typ
}

fn (p mut Parser) genln(s string) {
	p.cgen.genln(s)
}

fn (p mut Parser) gen(s string) {
	p.cgen.gen(s)
}

// Generate NEO header from NEO source
fn (p mut Parser) vh_genln(s string) {
	p.nh_lines << s
}

fn (p mut Parser) fmt_inc() {
	p.scanner.fmt_indent++
}

fn (p mut Parser) fmt_dec() {
	p.scanner.fmt_indent--
}

fn (p mut Parser) statement(add_semi bool) string {
	p.cgen.is_tmp = false
	tok := p.tok
	mut q := ''
	switch tok {
	case token_name:
		next := p.peek()
		if p.is_verbose {
			println(next.str())
		}
		// goto_label:
		if p.peek() == colon {
			p.fmt_dec()
			label := p.check_name()
			p.fmt_inc()
			p.genln(label + ':')
			p.check(colon)
			return ''
		}
		else if p.peek() == decl_assign {
			p.log('var decl')
			p.var_decl()
		}
		else if p.lit == 'jsdecode' {
			p.js_decode()
		}
		else {
			// "a + 3", "a(7)" or maybe just "a"
			q = p.bool_expression()
		}
	case keyword_goto:
		p.check(keyword_goto)
		p.fgen(' ')
		label := p.check_name()
		p.genln('goto $label;')
		return ''
	case hash:
		p.chash()
		return ''
	case dollar:
		p.comp_time()
	case keyword_if:
		p.if_st(false)
	case keyword_for:
		p.for_st()
	case keyword_switch, keyword_match:
		p.switch_statement()
	case keyword_mut, keyword_static:
		p.var_decl()
	case keyword_return:
		p.return_st()
	case left_cbr:// {} block
		p.next()
		p.genln('{')
		p.statements()
		return ''
	case keyword_continue:
		if p.for_expr_cnt == 0 {
			p.error('`continue` statement outside `for`')
		}
		p.genln('continue')
		p.next()
	case keyword_break:
		if p.for_expr_cnt == 0 {
			p.error('`break` statement outside `for`')
		}
		p.genln('break')
		p.next()
	case keyword_go:
		p.go_statement()
	case keyword_assert:
		p.assert_statement()
	default:
		// An expression as a statement
		typ := p.expression()
		if p.inside_if_expr {
		}
		else {
			p.genln('; ')
		}
		return typ
	}
	// ? : uses , as statement separators
	if p.inside_if_expr && p.tok != right_cbr {
		p.gen(', ')
	}
	if add_semi && !p.inside_if_expr {
		p.genln(';')
	}
	return q
	// p.cgen.end_statement()
}

// is_map: are we in map assignment? (m[key] = val) if yes, dont generate '='
// this can be `user = ...`  or `user.field = ...`, in both cases `n` is `user`
fn (p mut Parser) assign_statement(n Var, ph int, is_map bool) {
	p.log('assign_statement() name=$n.name tok=')
	// p.print_tok()
	// p.gen(name)
	// p.assigned_var = name
	tok := p.tok
	if !n.is_mut && !n.is_arg && !p.translated {
		p.error('`$n.name` is immutable')
	}
	if !n.is_mut && p.is_play && !p.builtin_pkg && !p.translated {
		// no mutable args in play
		p.error('`$n.name` is immutable')
	}
	is_str := n.typ == 'string'
	switch tok {
	case assign:
		if !is_map {
			p.gen(' = ')
		}
	case plus_assign:
		if is_str {
			p.gen('= string_add($n.name, ')// TODO can't do `foo.bar += '!'`
		}
		else if !is_map {
			p.gen(' += ')
		}
	default:
		if 	tok != minus_assign 					&& tok != mul_assign					&& tok != xor_assign
		 && tok != mod_assign							&& tok != and_assign 					&& tok != or_assign
		 && tok != right_shift_assign 		&& tok != left_shift_assign 	&& tok != div_assign {
			p.gen(' ' + p.tok.str() + ' ')
		}
	}
	p.fgen(' ' + p.tok.str() + ' ')
	p.next()
	pos := p.cgen.cur_line.len
	expr_type := p.bool_expression()
	// Allow `num = 4` where `num` is an `?int`
	if p.assigned_type.starts_with('Option_') && expr_type == p.assigned_type.right('Option_'.len) {
		println('allowing option asss')
		expr := p.cgen.cur_line.right(pos)
		left := p.cgen.cur_line.left(pos)
		p.cgen.cur_line = left + 'opt_ok($expr)'
	}
	else if !p.builtin_pkg && !p.check_types_no_throw(expr_type, p.assigned_type) {
		p.scanner.line_nr--
		p.error('cannot use type `$expr_type` as type `$p.assigned_type` in assignment')
	}
	if is_str && tok == plus_assign {
		p.gen(')')
	}
	// p.assigned_var = ''
	p.assigned_type = ''
	if !n.is_used {
		p.cur_fn.mark_var_used(n)
	}
}

fn (p mut Parser) var_decl() {
	is_mut := p.tok == keyword_mut || p.prev_tok == keyword_for
	is_static := p.tok == keyword_static
	if p.tok == keyword_mut {
		p.check(keyword_mut)
		p.fspace()
	}
	if p.tok == keyword_static {
		p.check(keyword_static)
		p.fspace()
	}
	// println('var decl tok=${p.strtok()} ismut=$is_mut')
	name := p.check_name()
	p.fgen(' := ')
	// Don't allow declaring a variable with the same name. Even in a child scope
	// (shadowing is not allowed)
	if !p.builtin_pkg && p.cur_fn.known_var(name) {
		n := p.cur_fn.find_var(name)
		p.error('redefinition of `$name`')
		// Check if this variable has already been declared only in the first run.
		// Otherwise the is_script code outside main will run in the first run
		// since we can't skip the function body since there's no function.
		// And the variable will be registered twice.
		if p.is_play && p.first_run() && !p.builtin_pkg {
			p.error('variable `$name` is already declared.')
		}
	}
	// println('var_decl $name')
	// p.assigned_var = name
	p.next()// :=
	// Generate expression to tmp because we need its type first
	// [TYP token_name =] bool_expression()
	pos := p.cgen.add_placeholder()
	// p.gen('typ $name = ')
	// p.gen('/*^^^*/')
	mut typ := p.bool_expression()
	// p.gen('/*VVV*/')
	// Option check ? or {
	or_else := p.tok == keyword_orelse
	tmp := p.get_tmp()
	// assigned_var_copy := p.assigned_var
	if or_else {
		// Option_User tmp = get_user(1);
		// if (!tmp.ok) { or_statement }
		// User user = *(User*)tmp.data;
		// p.assigned_var = ''
		p.cgen.set_placeholder(pos, '$typ $tmp = ')
		p.gen(';')
		typ = typ.replace('Option_', '')
		p.next()
		p.check(left_cbr)
		p.genln('if (!$tmp .ok) {')
		p.statements()
		p.genln('$typ $name = *($typ*) $tmp . data;')
		if !p.returns && p.prev_tok2 != keyword_continue && p.prev_tok2 != keyword_break {
			println(p.prev_tok2)
			p.error('`or` statement must return/continue/break')
		}
		// p.assigned_var = assigned_var_copy
	}
	p.register_var(Var {
		name: name
		typ: typ
		is_mut: is_mut
	})
	mut cgen_typ := typ
	if !or_else {
		gen_name := p.table.var_cgen_name(name)
		// p.cgen.set_placeholder(pos, '$cgen_typ $gen_name = ')
		mut nt_gen := p.table.cgen_name_type_pair(gen_name, cgen_typ) + '='
		if is_static {
			nt_gen = 'static $nt_gen'
			// p.gen('static ')
		}
		p.cgen.set_placeholder(pos, nt_gen)
	}
}

fn (p mut Parser) bool_expression() string {
	tok := p.tok
	typ := p.bterm()
	for p.tok == and || p.tok == lor {
		p.gen(' ${p.tok.str()} ')
		p.next()
		p.check_types(p.bterm(), typ)
	}
	if typ == '' {
		println('curline:')
		println(p.cgen.cur_line)
		println(tok.str())
		p.error('expr() returns empty type')
	}
	return typ
}

fn (p mut Parser) bterm() string {
	ph := p.cgen.add_placeholder()
	mut typ = p.expression()
	is_str := typ.eq('string')
	tok := p.tok
	// if tok in [ eq, gt, lt, le, ge, ne] {
	if tok == eq || tok == gt || tok == lt || tok == le || tok == ge || tok == ne {
		p.fgen(' ${p.tok.str()} ')
		if is_str {
			p.gen(',')
		}
		else {
			p.gen(tok.str())
		}
		p.next()
		p.check_types(p.expression(), typ)
		typ = 'bool'
		if is_str {
			p.gen(')')
			switch tok {
			case eq: p.cgen.set_placeholder(ph, 'string_eq(')
			case ne: p.cgen.set_placeholder(ph, 'string_ne(')
			case le: p.cgen.set_placeholder(ph, 'string_le(')
			case ge: p.cgen.set_placeholder(ph, 'string_ge(')
			case gt: p.cgen.set_placeholder(ph, 'string_gt(')
			case lt: p.cgen.set_placeholder(ph, 'string_lt(')
			}
		}
	}
	return typ
}

// also called on *, &
fn (p mut Parser) name_expr() string {
	p.log('\nname expr() pass=$p.run tok=${p.tok.str()} $p.lit')
	// print('known type:')
	// println(p.table.known_type(p.lit))
	// hack for struct_init TODO
	hack_pos := p.scanner.pos
	hack_tok := p.tok
	hack_lit := p.lit
	// amp
	ptr := p.tok == amp
	deref := p.tok == mul
	if ptr || deref {
		p.next()
	}
	if deref {
		if p.is_play && !p.builtin_pkg {
			p.error('dereferencing is temporarily disabled on the playground, will be fixed soon')
		}
	}
	mut name := p.lit
	p.fgen(name)
	// known_type := p.table.known_type(name)
	orig_name := name
	is_c := name == 'C' && p.peek() == sdot
	mut is_c_struct_init := is_c && ptr// a := &C.mycstruct{}
	if is_c {
		p.next()
		p.check(sdot)
		name = p.lit
		p.fgen(name)
		// Currently struct init is set to true only we have `&C.Foo{}`, handle `C.Foo{}`:
		if !is_c_struct_init && p.peek() == left_cbr {
			is_c_struct_init = true
		}
	}
	// //////////////////////////
	// module ?
	// Allow shadowing (gg = gg.newcontext(); gg.draw_triangle())
	if p.table.known_pkg(name) && !p.cur_fn.known_var(name) {
		// println('"$name" is a known pkg')
		pkg := name
		p.next()
		p.check(sdot)
		name = p.lit
		p.fgen(name)
		name = prepend_pkg(pkg, name)
	}
	else if !p.table.known_type(name) && !p.cur_fn.known_var(name) &&
	!p.table.known_fn(name) && !p.table.known_const(name) && !is_c {
		name = p.prepend_pkg(name)
	}
	// Variable
	n := p.cur_fn.find_var(name)
	if n.name.len != 0 {
		if ptr {
			p.gen('& /*vvar*/ ')
		}
		else if deref {
			p.gen('*')
		}
		mut typ := p.var_expr(n)
		// *var
		if deref {
			if !typ.contains('*') && !typ.ends_with('ptr') {
				println('name="$name", t=$n.typ')
				p.error('dereferencing requires a pointer, but got `$typ`')
			}
			typ = typ.replace('ptr', '')// TODO
			typ = typ.replace('*', '')// TODO
		}
		// &var
		else if ptr {
			typ += '*'
		}
		return typ
	}
	// if known_type || is_c_struct_init || (p.first_run() && p.peek() == left_cbr) {
	// known type? int(4.5) or Color.green (enum)
	if p.table.known_type(name) {
		// float(5), byte(0), (*int)(ptr) etc
		if p.peek() == left_par || (deref && p.peek() == right_par) {
			// println('CASTT $name')
			if deref {
				// p.check(right_par)
				// p.next()
				name += '*'
			}
			else if ptr {
				name += '*'
			}
			p.gen('(/*casttt*/')
			mut typ := p.cast(name)
			p.gen(')')
			for p.tok == sdot {
				typ = p.dot(typ, 0)
			}
			return typ
		}
		// Color.green
		else if p.peek() == sdot {
			enum_type := p.table.find_type(name)
			if !enum_type.is_enum {
				p.error('`$name` is not an enum')
			}
			p.next()
			p.check(sdot)
			val := p.lit
			// println('enum val $val')
			p.gen(p.pkg + '__' + enum_type.name + '_' + val)// `color = main__Color_green`
			p.next()
			return enum_type.name
		}
		else {
			// go back to name start (pkg.name)
			p.scanner.pos = hack_pos
			p.tok = hack_tok
			p.lit = hack_lit
			// TODO hack. If it's a C type, we may need to add struct before declaration:
			// a := &C.A{}  ==>  struct A* a = malloc(sizeof(struct A));
			if is_c_struct_init && name != 'tm' {
				p.cgen.insert_before('struct ')
			}
			return p.struct_init(is_c_struct_init)
		}
	}
	// C fn
	if is_c {
		f := Fn {
			name: name// .replace('c_', '')
			is_c: true
		}
		p.fn_call(f, 0, '', '')
		// Try looking it up. Maybe its defined with "C.fn_name() fn_type",
		// then we know what type it returns
		cfn := p.table.find_fn(name)
		// Not Found? Return 'void*'
		if cfn.name == '' {
			return 'void*'
		}
		return cfn.typ
	}
	// Constant
	mut c := p.table.find_const(name)
	if c.name != '' && ptr && !c.is_global {
		p.error('cannot take the address of constant `$c.name`')
	}
	if c.name.len != 0 {
		if ptr {
			// c.ptr = true
			p.gen('& /*const*/ ')
		}
		p.log('calling var expr')
		mut typ := p.var_expr(c)
		if ptr {
			typ += '*'
		}
		return typ
	}
	// Function (not method btw, methods are handled in dot())
	f := p.table.find_fn(name)
	if f.name == '' {
		println(p.cur_fn.name)
		println(p.cur_fn.args.len)
		// if !p.first_run() && !p.translated {
		if !p.first_run() {
			// println('name_expr():')
			// If orig_name is a pkg, then printing undefined: `pkg` tells us nothing
			if p.table.known_pkg(orig_name) {
				name = name.replace('__', '.')
				p.error('undefined: `$name`')
			}
			else {
				p.error('undefined: `$orig_name`')
			}
		}
		p.next()
		return 'void'
	}
	// no () after func, so func is an argument, just gen its name
	// TODO verify this and handle errors
	if p.peek() != left_par {
		p.gen(p.table.cgen_name(f))
		p.next()
		return 'void*'
	}
	// TODO bring back
	if f.typ == 'void' && !p.inside_if_expr {
		// p.error('`$f.name` used as value')
	}
	p.log('calling function')
	p.fn_call(f, 0, '', '')
	// dot after a function call: `get_user().age`
	if p.tok == sdot {
		mut typ := ''
		for p.tok == sdot {
			// println('dot #$dc')
			typ = p.dot(f.typ, 0)
		}
		return typ
	}
	p.log('end of name_expr')
	return f.typ
}

fn (p mut Parser) var_expr(n Var) string {
	p.log('\nvar_expr() n.name="$n.name" n.typ="$n.typ"')
	// println('var expr is_tmp=$p.cgen.is_tmp\n')
	// p.gen('VAR EXPR ')
	p.cur_fn.mark_var_used(n)
	fn_ph := p.cgen.add_placeholder()
	p.expr_var = n
	p.gen(p.table.var_cgen_name(n.name))
	p.next()
	mut typ := n.typ
	// fn_pointer()
	if typ.starts_with('fn ') {
		println('CALLING FN PTR')
		p.print_tok()
		T := p.table.find_type(typ)
		p.gen('(')
		p.fn_call_args(T.func)
		p.gen(')')
		typ = T.func.typ
	}
	// users[0] before dot so that we can have
	// users[0].name
	if p.tok == left_sbr {
		typ = p.index_expr(typ, fn_ph)
		// ////println('QQQQ KEK $typ')
	}
	// a.b.c().d chain
	// mut dc := 0
	for p.tok == sdot {
		// println('dot #$dc')
		typ = p.dot(typ, fn_ph)
		p.log('typ after dot=$typ')
		// print('tok after dot()')
		// p.print_tok()
		// dc++
		if p.tok == left_sbr {
			// typ = p.index_expr(typ, fn_ph, n)
		}
	}
	// a++ and a--
	if p.tok == inc || p.tok == dcm {
		if !n.is_mut && !n.is_arg && !p.translated {
			p.error('`$n.name` is immutable')
		}
		if typ != 'int' {
			if !p.translated && !is_number_type(typ) {
				// if T.parent != 'int' {
				p.error('cannot ++/-- value of type `$typ`')
			}
		}
		p.gen(p.tok.str())
		p.fgen(p.tok.str())
		p.next()// ++
		// allow a := c++ in translated
		if p.translated {
			return p.index_expr(typ, fn_ph)
			// return typ
		}
		else {
			return 'void'
		}
	}
	typ = p.index_expr(typ, fn_ph)
	return typ
}

fn (p &Parser) fileis(s string) bool {
	return p.scanner.file_path.contains(s)
}

// user.name => `str_typ` is `User`
// user.company.name => `str_typ` is `Company`
fn (p mut Parser) dot(str_typ string, method_ph int) string {
	p.check(sdot)
	field_name := p.lit
	p.fgen(field_name)
	p.log('dot() field_name=$field_name typ=$str_typ')
	if p.fileis('hi_test') {
		println('dot() field_name=$field_name typ=$str_typ')
	}
	typ := p.find_type(str_typ)
	if typ.name.len == 0 {
		p.error('dot(): cannot find type `$str_typ`')
	}
	has_field := p.table.type_has_field(typ, field_name)
	has_method := p.table.type_has_method(typ, field_name)
	if !typ.is_c && !has_field && !has_method && !p.first_run() {
		// println(typ.str())
		if typ.name.starts_with('Option_') {
			opt_type := typ.name.substr(7, typ.name.len)
			p.error('unhandled option type: $opt_type?')
		}
		println('dot():')
		println('fields:')
		for field in typ.fields {
			println(field.name)
		}
		println('methods:')
		for field in typ.methods {
			println(field.name)
		}
		println('str_typ=="$str_typ"')
		p.error('type `$typ.name`  has no field or method `$field_name`')
	}
	mut dot := '.'
	if str_typ.contains('*') {
		dot = '->'
	}
	// field
	if has_field {
		field := p.table.find_field(typ, field_name)
		// Is the next token `=`, `+=` etc?  (Are we modifying the field?)
		next := p.peek()
		modifying := next.is_assign() || next == inc || next == dcm
		is_vi := p.fileis('vi')
		if !p.builtin_pkg && !p.translated && modifying && !field.is_mut && !is_vi {
			p.error('cannot modify immutable field `$field_name` (type `$typ.name`)')
		}
		if !p.builtin_pkg && p.pkg != typ.pkg {
		}
		// if p.is_play && field.access_mod == private && !p.builtin_pkg && p.pkg != typ.pkg {
		// Don't allow `arr.data`
		if field.access_mod == private && !p.builtin_pkg && !p.translated && p.pkg != typ.pkg {
			// println('$typ.name :: $field.name ')
			// println(field.access_mod)
			p.error('cannot refer to unexported field `$field_name` (type `$typ.name`)')
		}
		// if field.access_mod == public && p.peek() == assign && !p.builtin_pkg && p.pkg != typ.pkg {
		// Don't allow `str.len = 0`
		if field.access_mod == public && !p.builtin_pkg && p.pkg != typ.pkg {
			// if field.name == 'age' {
			// println('HOHOH')
			// println(next.str())
			// }
			if !field.is_mut && !p.translated && modifying {
				p.error('cannot modify public immutable field `$field_name` (type `$typ.name`)')
			}
		}
		p.gen('${dot}${field_name}')
		// p.gen(dot + field_name)
		p.next()
		return field.typ
	}
	// method
	// mut method := typ.find_method(field_name)
	mut method := p.table.find_method(typ, field_name)
	p.fn_call(method, method_ph, '', str_typ)
	// Methods returning "array" (like slice_fast) should return "array_string"
	if method.typ == 'array' && typ.name.starts_with('array_') {
		return typ.name
	}
	// Array Methods returning `voidptr` (like `last()`) should return element type
	if method.typ == 'void*' && typ.name.starts_with('array_') {
		// return typ.name.replace('array_', '')
		return typ.name.right(6)
	}
	if false && p.tok == left_sbr {
		// if is_indexer {
		return p.index_expr(method.typ, method_ph)
	}
	return method.typ
}

fn (p mut Parser) index_expr(typ string, fn_ph int) string {
	if p.fileis('int_test') {
		println('index expr typ=$typ')
	}
	// a[0]
	n := p.expr_var
	is_map := typ.starts_with('map_')
	is_str := typ == 'string'
	is_arr0 := typ.starts_with('array_')
	is_arr := is_arr0 || typ == 'array'
	is_ptr := typ == 'byte*' || typ == 'byteptr' || typ.contains('*')
	is_indexer := p.tok == left_sbr
	mut close_bracket := false
	if is_indexer {
		is_fixed_arr := typ[0] == `[`
		if !is_str && !is_arr && !is_map && !is_ptr && !is_fixed_arr {
			p.error('Cant [] non-array/string/map. Got type "$typ"')
		}
		p.check(left_sbr)
		// Get element type (set `typ` to it)
		if is_str {
			typ = 'byte'
			p.fgen('[')
			// Direct faster access to .str[i] in builtin package
			if p.builtin_pkg {
				p.gen('.str[')
				close_bracket = true
			}
			else {
				// Bounds check everywhere else
				p.gen(',')
			}
		}
		if is_fixed_arr {
			// `[10]int` => `int`, `[10][3]int` => `[3]int`
			if typ.contains('][') {
				pos := typ.index_after('[', 1)
				typ = typ.right(pos)
			}
			else {
				typ = typ.all_after(']')
			}
			p.gen('[')
			close_bracket = true
		}
		else if is_ptr {
			// typ = 'byte'
			typ = typ.replace('*', '')
			// modify(mut []string) fix
			if !is_arr {
				p.gen('[/*ptr*/')
				close_bracket = true
			}
		}
		if is_arr {
			p.fgen('[')
			// array_int a; a[0]
			// type is "array_int", need "int"
			// typ = typ.replace('array_', '')
			if is_arr0 {
				if p.fileis('int_test') {
					println('\nRRRR0 $typ')
				}
				typ = typ.right(6)
				if p.fileis('int_test') {
					println('RRRR $typ')
				}
			}
			// array a; a.first() voidptr
			// type is "array", need "void*"
			if typ == 'array' {
				typ = 'void*'
			}
			// No bounds check in translated from C code
			if p.translated {
				// Cast void* to typ*: add (typ*) to the beginning of the assignment :
				// ((int*)a.data = ...
				p.cgen.set_placeholder(fn_ph, '(($typ*)(')
				p.gen('.data))[')
			}
			else {
				p.gen(',')
			}
		}
		// map is tricky
		// need to replace "m[key] = val" with "tmp = val; map_set(&m, key, &tmp)"
		// need to replace "m[key]"       with "tmp = val; map_get(&m, key, &tmp)"
		// can only do that later once we know whether there's an "=" or not
		if is_map {
			typ = typ.replace('map_', '')
			if typ == 'map' {
				typ = 'void*'
			}
			p.gen(',')
		}
		// expression inside [ ]
		if is_arr {
			T := p.table.find_type(p.expression())
			if T.parent != 'int' {
				p.check_types(T.name, 'int')
			}
		}
		else {
			p.expression()
		}
		p.check(right_sbr)
		// if (is_str && p.builtin_pkg) || is_ptr || is_fixed_arr && ! (is_ptr && is_arr) {
		if close_bracket {
			p.gen(']/*r$typ $n.is_mut*/')
		}
	}
	// TODO if p.tok in ...
	// if p.tok in [assign, plus_assign, minus_assign]
	if p.tok == assign || p.tok == plus_assign || p.tok == minus_assign ||
	p.tok == mul_assign || p.tok == div_assign || p.tok == xor_assign || p.tok == mod_assign ||
	p.tok == or_assign || p.tok == and_assign || p.tok == right_shift_assign ||
	p.tok == left_shift_assign {
		if is_map || is_arr {
			// Don't generate indexer right away, but assign it to tmp
			// p.cgen.start_tmp()
		}
		if is_indexer && is_str && !p.builtin_pkg {
			p.error('strings are immutable')
		}
		// println('111 "$p.cgen.cur_line"')
		assign_pos := p.cgen.cur_line.len
		p.assigned_type = typ
		p.assign_statement(n, fn_ph, is_indexer && (is_map || is_arr))
		// m[key] = val
		if is_indexer && (is_map || is_arr) {
			// a[0] = 7
			// curline right now: "a , 0  =  7"
			// println('222 "$p.cgen.cur_line"')
			// Cant have &7, so need a tmp
			tmp := p.get_tmp()
			tmp_val := p.cgen.cur_line.right(assign_pos)
			p.cgen.cur_line = p.cgen.cur_line.left(assign_pos)
			// val := p.cgen.end_tmp()
			if is_map {
				p.cgen.set_placeholder(fn_ph, 'map__set(&')
			}
			else {
				if is_ptr {
					p.cgen.set_placeholder(fn_ph, 'array_set(')
				}
				else {
					p.cgen.set_placeholder(fn_ph, 'array_set(&/*q*/')
				}
			}
			p.gen(', & $tmp)')
			p.cgen.insert_before('$typ $tmp = $tmp_val;')
		}
		return typ
		return 'void'
	}
	// else if p.is_verbose && p.assigned_var != '' {
	// p.error('didnt assign')
	// }
	// m[key]. no =, just a getter
	else if (is_map || is_arr || (is_str && !p.builtin_pkg)) && is_indexer {
		// Erase var name we generated earlier:	"int a = m, 0"
		// "m, 0" gets killed since we need to start from scratch. It's messy.
		// "m, 0" is an index expression, save it before deleting and insert later in map_get()
		index_expr := p.cgen.cur_line.right(fn_ph)
		p.cgen.cur_line = p.cgen.cur_line.left(fn_ph)
		// Can't pass integer literal, because map_get() requires a void*
		tmp := p.get_tmp()
		tmp_ok := p.get_tmp()
		if is_map {
			p.gen('$tmp')
			def := type_default(typ)
			p.cgen.insert_before('$typ $tmp = $def; bool $tmp_ok = map_get($index_expr, & $tmp);')
		}
		else if is_arr {
			if p.translated {
				p.gen('$index_expr ]')
			}
			else {
				p.gen('( *($typ*) array__get($index_expr) )')
			}
		}
		else if is_str && !p.builtin_pkg {
			p.gen('string_at($index_expr)')
		}
		// Zero the string after map_get() if it's nil, numbers are automatically 0
		// This is ugly, but what can I do without generics?
		// TODO what about user types?
		if is_map && typ == 'string' {
			// p.cgen.insert_before('if (!${tmp}.str) $tmp = tos("", 0);')
			p.cgen.insert_before('if (!$tmp_ok) $tmp = tos("", 0);')
		}
	}
	// else if is_arr && is_indexer{}
	return typ
}

// returns resulting type
fn (p mut Parser) expression() string {
	if p.scanner.file_path.contains('test_test') {
		println('epxression() pass=$p.run tok=')
		p.print_tok()
	}
	p.cgen('/* expr start*/')
	ph := p.cgen.add_placeholder()
	mut typ := p.term()
	is_str := typ.eq('string')
	// a << b ==> array2_push(&a, b)
	if p.tok == left_shift {
		if typ.contains('array_') {
			// Can't pass integer literal, because push requires a void*
			// a << 7 => int tmp = 7; array_push(&a, &tmp);
			// _PUSH(&a, expression(), tmp, string)
			tmp := p.get_tmp()
			tmp_typ := typ.right(6)// skip "array_"
			p.next()
			// Get the value we are pushing
			p.gen(', (')
			// Immutable? Can we push?
			if !p.expr_var.is_mut && !p.translated {
				p.error('`$p.expr_var.name` is immutable (can\'t <<)')
			}
			p.check_types(p.expression(), tmp_typ)
			// Pass tmp var info to the _PUSH macro
			p.gen('), $tmp, $tmp_typ)')
			// Prepend tmp initialisation and push call
			// Don't dereference if it's already a mutable array argument  (`fn foo(mut []int)`)
			push_call := if typ.contains('*'){'_PUSH('} else { '_PUSH(&'} // p.cgen.set_placeholder(ph, '_PUSH(&')
			p.cgen.set_placeholder(ph, push_call)
			return 'void'
		}
		else {
			p.next()
			p.gen(' << ')
			p.check_types(p.expression(), typ)
			return 'int'
		}
	}
	// a in [1,2,3]
	if p.tok == keyword_in {
		p.fgen(' ')
		p.check(keyword_in)
		p.fgen(' ')
		p.gen(', ')
		arr_typ := p.expression()
		if !arr_typ.starts_with('array_') {
			p.error('`in` requires an array')
		}
		T := p.table.find_type(arr_typ)
		if !T.has_method('contains') {
			p.error('$arr_typ has no method `contains`')
		}
		// `typ` is element type
		p.cgen.set_placeholder(ph, '_IN($typ, ')
		p.gen(')')
		return 'bool'
	}
	if p.tok == right_shift {
		p.next()
		p.gen(' >> ')
		p.check_types(p.expression(), typ)
		return 'int'
	}
	if p.tok == sdot {
		for p.tok == sdot {
			typ = p.dot(typ, 0)
		}
	}
	// + - |
	for p.tok == plus || p.tok == minus || p.tok == pipe || p.tok == amp || p.tok == xor {
		// for p.tok in [plus, minus, pipe, amp, xor] {
		tok_op := p.tok
		is_num := typ == 'void*' || typ == 'byte*' || is_number_type(typ)
		p.next()
		if is_str && tok_op == plus {
			p.cgen.set_placeholder(ph, 'string_add(')
			p.gen(',')
		}
		// 3 + 4
		else if is_num {
			p.gen(tok_op.str())
		}
		// Vec + Vec
		else {
			if p.translated {
				p.gen(tok_op.str() + ' /*doom hack*/')// TODO hack to fix DOOM's angle_t
			}
			else {
				p.gen(',')
			}
		}
		p.check_types(p.term(), typ)
		if is_str && tok_op == plus {
			p.gen(')')
		}
		// Make sure operators are used with correct types
		if !p.translated && !is_str && !is_num {
			T := p.table.find_type(typ)
			if tok_op == plus {
				if T.has_method('+') {
					p.cgen.set_placeholder(ph, typ + '_plus(')
					p.gen(')')
				}
				else {
					p.error('operator + not defined on `$typ`')
				}
			}
			else if tok_op == minus {
				if T.has_method('-') {
					p.cgen.set_placeholder(ph, '${typ}_minus(')
					p.gen(')')
				}
				else {
					p.error('operator - not defined on `$typ`')
				}
			}
		}
	}
	return typ
}

fn (p mut Parser) term() string {
	line_nr := p.scanner.line_nr
	if p.fileis('fn_test') {
		println('\nterm() $line_nr')
	}
	typ := p.unary()
	if p.fileis('fn_test') {
		println('2: $line_nr')
	}
	// `*` on a newline? Can't be multiplication, only dereference
	if p.tok == mul && line_nr != p.scanner.line_nr {
		return typ
	}
	for p.tok == mul || p.tok == div || p.tok == mod {
		tok := p.tok
		is_div := tok == div
		is_mod := tok == mod
		// is_mul := tok == mod
		p.next()
		p.gen(tok.str())// + ' /*op2*/ ')
		p.fgen(' ' + tok.str() + ' ')
		if is_div && p.tok == token_int && p.lit == '0' {
			p.error('division by zero')
		}
		if is_mod && (is_float_type(typ) || !is_number_type(typ)) {
			p.error('operator mod requires integer types')
		}
		p.check_types(p.unary(), typ)
	}
	return typ
}

fn (p mut Parser) unary() string {
	mut typ := ''
	tok := p.tok
	switch tok {
	case not:
		p.gen('!')
		p.next()
		typ = 'bool'
		p.bool_expression()
	case bit_not:
		p.gen('~')
		p.next()
		typ = p.bool_expression()
	default:
		typ = p.factor()
	}
	return typ
}

fn (p mut Parser) factor() string {
	mut typ := ''
	tok := p.tok
	switch tok {
	case token_int:
		typ = 'int'
		if p.lit.contains('.') || p.lit.contains('e') {
			typ = 'f32'
			// typ = 'f64' // TODO 
		}
		p.gen(p.lit)
		p.fgen(p.lit)
	case minus:
		p.gen('-')
		p.fgen('-')
		p.next()
		return p.factor()
		// Variable
	case keyword_sizeof:
		p.gen('sizeof(')
		p.fgen('sizeof(')
		p.next()
		p.check(left_par)
		mut sizeof_typ := p.get_type()
		if sizeof_typ.ends_with('*') {
			// Move * from the end to the beginning, as C requires
			sizeof_typ = '*' + sizeof_typ.left(sizeof_typ.len - 1)
		}
		p.check(right_par)
		p.gen('$sizeof_typ)')
		p.fgen('$sizeof_typ)')
		return 'int'
	case amp:
		return p.name_expr()
	case sdot:
		return p.name_expr()// `.green` (enum)
	case mul:
		return p.name_expr()
	case token_name:
		// map[string]int
		if p.lit == 'map' && p.peek() == left_sbr {
			return p.map_init()
		}
		if p.lit == 'json' && p.peek() == sdot {
			return p.js_decode()
		}
		typ = p.name_expr()
		return typ
	case keyword_default:
		p.next()
		p.next()
		name := p.check_name()
		if name != 'T' {
			p.error('default needs T')
		}
		p.gen('default(T)')
		p.next()
		return 'T'
	case left_par:
		p.gen('(/*lpar*/')
		p.next()// (
		typ = p.bool_expression()
		// Hack. If this `)` referes to a ptr cast `(*int__)__`, it was already checked
		// TODO: fix parser so that it doesn't think it's a par expression when it sees `(` in
		// __(__*int)(
		if !p.ptr_cast {
			p.check(right_par)
		}
		p.ptr_cast = false
		p.gen(')')
		return typ
	case token_char:
		p.char_expr()
		typ = 'byte'
		return typ
	case token_string:
		p.string_expr()
		typ = 'string'
		return typ
	case keyword_false:
		typ = 'bool'
		p.gen('0')
		p.fgen('false')
	case keyword_true:
		typ = 'bool'
		p.gen('1')
		p.fgen('true')
	case left_sbr:
		// `[1,2,3]` or `[]` or `[20]byte`
		// TODO have to return because arrayInit does next()
		// everything should do next()
		return p.array_init()
	case left_cbr:
		// { user | name :'new name' }
		return p.assoc()
	case keyword_if:
		typ = p.if_st(true)
		return typ
	default:
		next := p.peek()
		println('PREV=${p.prev_tok.str()}')
		println('NEXT=${next.str()}')
		p.error('unexpected token: `${p.tok.str()}`')
	}
	p.next()// TODO everything should next()
	return typ
}

// { user | name: 'new name' }
fn (p mut Parser) assoc() string {
	// println('assoc()')
	p.next()
	name := p.check_name()
	if !p.cur_fn.known_var(name) {
		p.error('unknown variable `$name`')
	}
	var := p.cur_fn.find_var(name)
	p.check(pipe)
	p.gen('($var.typ){')
	mut fields := []string// track the fields user is setting, the rest will be copied from the old object
	for p.tok != right_cbr {
		field := p.check_name()
		fields << field
		p.gen('.$field = ')
		p.check(colon)
		p.bool_expression()
		p.gen(',')
		if p.tok != right_cbr {
			p.check(comma)
		}
	}
	// Copy the rest of the fields
	T := p.table.find_type(var.typ)
	for ffield in T.fields {
		f := ffield.name
		if f in fields {
			continue
		}
		p.gen('.$f = $name . $f,')
	}
	p.check(right_cbr)
	p.gen('}')
	return var.typ
}

fn (p mut Parser) char_expr() {
	p.gen('\'$p.lit\'')
	p.next()
}

fn format_str(str string) string {
	str = str.replace('"', '\\"')
	str = str.replace('\n', '\\n')
	return str
}

fn (p mut Parser) typ_to_fmt(typ string) string {
	t := p.table.find_type(typ)
	if t.parent == 'int' {
		return '%d'
	}
	switch typ {
	case 'string': return '%.*s'
	case 'ustring': return '%.*s'
	case 'byte': return '%d'
	case 'int': return '%d'
	case 'char': return '%d'
	case 'byte': return '%d'
	case 'bool': return '%d'
	case 'u32': return '%d'
	case 'f64', 'f32': return '%f'
	case 'i64': return '%lld'
	case 'byte*': return '%s'
		// case 'array_string': return '%s'
		// case 'array_int': return '%s'
	case 'void': p.error('cannot interpolate this value')
	default:
		p.error('unhandled sprintf format "$typ" ')
	}
	return ''
}

fn (p mut Parser) string_expr() {
	// println('token_string EXPR')
	str := p.lit
	p.fgen('\'$str\'')
	// No ${}, just return simple string
	if p.peek() != dollar {
		// println('before format: "$str"')
		f := format_str(str)
		// println('after format: "$str"')
		if p.calling_c || p.translated {
			p.gen('"$f"')
		}
		else {
			p.gen('tos2("$f")')// TODO dont call strlen here
		}
		p.next()
		return
	}
	// tmp := p.get_tmp()
	mut args := '"'
	mut format := '"'
	for p.tok == token_string {
		// Add the string between %d's
		format += format_str(p.lit)
		p.next()// skip $
		if p.tok != dollar {
			continue
		}
		// Handle dollar
		p.next()
		// Get bool expr inside a temp var
		p.cgen.start_tmp()
		typ := p.bool_expression()
		mut val := p.cgen.end_tmp()
		val = val.trim_space()
		args += ', $val'
		if typ == 'string' {
			// args += '.str'
			// printf("%.*s", a.len, a.str) syntax
			args += '.len, ${val}.str'
		}
		if typ == 'ustring' {
			args += '.len, ${val}.s.str'
		}
		// Custom format? ${t.hour:02d}
		custom := p.tok == colon
		if custom {
			format += '%'
			p.next()
			if p.tok == sdot {
				format += '.'
				p.next()
			}
			format += p.lit// 02
			p.next()
			format += p.lit// f
			// println('custom str F=$format')
			p.next()
		}
		else {
			format += p.typ_to_fmt(typ)
		}
	}
	// println("hello %d", num) optimization.
	if p.cgen.nogen {
		return
	}
	// Don't allocate a new string, just print	it. TODO HACK PRINT OPT
	cur_line := p.cgen.cur_line.trim_space()
	if cur_line.contains('println(') && p.tok != plus && !p.is_prod && !cur_line.contains('string_add') {
		p.cgen.cur_line = cur_line.replace('println(', 'printf(')
		p.gen('$format\\n$args')
		return
	}
	// '$age'! means the user wants this to be a tmp string (uses global buffer, no allocation,
	// won't be used	again)
	if p.tok == not {
		p.next()
		p.gen('_STR_TMP($format$args)')
	}
	else {
		// Otherwise do ugly len counting + allocation + sprintf
		p.gen('_STR($format$args)')
	}
}

// m := map[string]int{}
fn (p mut Parser) map_init() string {
	p.next()
	p.check(left_sbr)
	key_type := p.check_name()
	if key_type != 'string' {
		p.error('only string key maps allowed for now')
	}
	p.check(right_sbr)
	val_type := p.check_name()
	if !p.table.known_type(val_type) {
		p.error('map init unknown type "$val_type"')
	}
	p.gen('new_map(1, sizeof($val_type))')
	p.check(left_cbr)
	p.check(right_cbr)
	return 'map_$val_type'
}

// [1,2,3]
fn (p mut Parser) array_init() string {
	p.check(left_sbr)
	is_integer := p.tok == token_int
	lit := p.lit
	mut typ := ''
	new_arr_ph := p.cgen.add_placeholder()
	mut i := 0
	pos := p.cgen.cur_line.len// remember cur line to fetch first number in cgen  for [0; 10]
	for p.tok != right_sbr {
		val_typ := p.bool_expression()
		// Get type of the first expression
		if i == 0 {
			typ = val_typ
			// fixed width array initialization? (`arr := [20]byte`)
			if is_integer && p.tok == right_sbr && p.peek() == token_name {
				nextc := p.scanner.text[p.scanner.pos + 1]
				// TODO whitespace hack
				// Make sure there's no space in `[10]byte`
				if !nextc.is_space() {
					p.check(right_sbr)
					name := p.check_name()
					if p.table.known_type(name) {
						p.cgen.cur_line = ''
						p.gen('{} /* arkek init*/')
						return '[$lit]$name'
					}
					else {
						p.error('bad type `$name`')
					}
				}
			}
		}
		if val_typ != typ {
			if !p.check_types_no_throw(val_typ, typ) {
				p.error('bad array element type `$val_typ` instead of `$typ`')
			}
		}
		if p.tok != right_sbr && p.tok != semicolon {
			p.gen(',')
			p.check(comma)
		}
		i++
		// Repeat (a = [0;5] )
		if i == 1 && p.tok == semicolon {
			p.check_space(semicolon)
			val := p.cgen.cur_line.right(pos)
			// p.cgen.cur_line = ''
			p.cgen.cur_line = p.cgen.cur_line.left(pos)
			// Special case for zero
			if false && val.trim_space() == '0' {
				p.gen('array_repeat( & NEO_ZERO, ')
			}
			else {
				tmp := p.get_tmp()
				p.cgen.insert_before('$typ $tmp = $val;')
				p.gen('array_repeat(&$tmp, ')
			}
			p.check_types(p.bool_expression(), 'int')
			p.gen(', sizeof($typ) )')
			p.check(right_sbr)
			return 'array_$typ'
		}
	}
	p.check(right_sbr)
	// type after `]`? (e.g. "[]string")
	if p.tok != token_name && i == 0 {
		p.error('specify array type: `[]typ` instead of `[]`')
	}
	if p.tok == token_name && i == 0 {
		// vals.len == 0 {
		typ = p.get_type()
		// println('GOT TYP after [] $typ')
	}
	// ! after array => no malloc and no copy
	no_alloc := p.tok == not
	if no_alloc {
		p.next()
	}
	// [1,2,3]!! => [3]int{1,2,3}
	is_fixed_size := p.tok == not
	if is_fixed_size {
		p.next()
		p.gen(' }')
		if !p.first_run() {
			// If we are defining a const array, we don't need to specify the type:
			// `a = {1,2,3}`, not `a = (int[]) {1,2,3}`
			if p.inside_const {
				p.cgen.set_placeholder(new_arr_ph, '{ ')
			}
			else {
				p.cgen.set_placeholder(new_arr_ph, '($typ[]) { ')
			}
		}
		return '[$i]$typ'
	}
	// if ptr {
	// typ += '_ptr"
	// }
	mut new_arr := 'new_array_from_c_array'
	if no_alloc {
		new_arr += '_no_alloc'
	}
	p.gen(' })')
	// p.gen('$new_arr($vals.len, $vals.len, sizeof($typ), ($typ[]) $c_arr );')
	// TODO why need !first_run()?? Otherwise it goes to the very top of the out.c file
	if !p.first_run() {
		p.cgen.set_placeholder(new_arr_ph, '$new_arr($i, $i, sizeof($typ), ($typ[]) { ')
	}
	typ = 'array_$typ'
	p.register_array(typ)
	return typ
}

fn (p mut Parser) register_array(typ string) {
	if typ.contains('*') {
		println('bad arr $typ')
		return
	}
	if !p.table.known_type(typ) {
		p.register_type_with_parent(typ, 'array')
		p.cgen.typedefs << 'typedef array $typ;'
	}
}

// name == 'User'
fn (p mut Parser) struct_init(is_c_struct_init bool) string {
	p.is_struct_init = true
	mut typ := p.get_type()
	p.scanner.fmt_out.cut(typ.len)
	ptr := typ.contains('*')
	p.check(left_cbr)
	// tmp := p.get_tmp()
	if !ptr {
		if typ == 'tm' {
			p.gen('(struct tm) {')// TODO struct tm hack, handle all C structs
		}
		else {
			p.gen('($typ){')
		}
	}
	else {
		// TODO tmp hack for 0 pointers init
		// &User{!} ==> 0
		if p.tok == not {
			p.next()
			p.gen('0')
			p.check(right_cbr)
			return typ
		}
		mut type_gen := typ.replace('*', '')
		// All NEO types are typedef'ed, C structs aren't, so we need to prepend "struct "
		if is_c_struct_init {
			type_gen = 'struct $type_gen'
		}
		// p.gen('malloc(sizeof($type_gen)); \n')
		no_star := typ.replace('*', '')
		p.gen('ALLOC_INIT($no_star, {')
	}
	// Loop thru all struct init keys and assign values
	// u := User{age:20, name:'bob'}
	// Remember which fields were set, so that we dont have to zero them later
	mut inited_fields := []string
	peek := p.peek()
	if peek == colon || p.tok == right_cbr {
		t := p.table.find_type(typ)
		for p.tok != right_cbr {
			field := p.check_name()
			if !t.has_field(field) {
				p.error('`$t.name` has no field `$field`')
			}
			inited_fields << field
			p.gen('.$field = ')
			p.check(colon)
			p.fspace()
			p.expression()
			if p.tok == comma {
				p.next()
			}
			if p.tok != right_cbr {
				p.gen(',')
			}
			p.fgenln('')
		}
		// If we already set some fields, need to prepend a comma
		if t.fields.len != inited_fields.len && inited_fields.len > 0 {
			p.gen(',')
		}
		// Zero values: init all fields (ints to 0, strings to '' etc)
		for i, field in t.fields {
			// println('###field.name')
			// Skip if this field has already been assigned to
			if inited_fields.contains(field.name) {
				continue
			}
			field_typ := field.typ
			if !p.builtin_pkg && field_typ.ends_with('*') && field_typ.contains('Cfg') {
				p.error('pointer field `${typ}.${field.name}` must be initialized')
			}
			def_val := type_default(field_typ)
			if def_val != '' {
				p.gen('.$field.name = $def_val')
				if i != t.fields.len - 1 {
					p.gen(',')
				}
			}
		}
	}
	// Point{3,4} syntax
	else {
		mut T := p.table.find_type(typ)
		// Aliases (TODO Hack, implement proper aliases)
		if T.fields.len == 0 && T.parent != '' {
			T = p.table.find_type(T.parent)
		}
		for i, ffield in T.fields {
			expr_typ := p.bool_expression()
			if !p.check_types_no_throw(expr_typ, ffield.typ) {
				p.error('field value #${i+1} `$ffield.name` has type `$ffield.typ`, got `$expr_typ` ')
			}
			if i < T.fields.len - 1 {
				if p.tok != comma {
					p.error('too few values in `$typ` literal (${i+1} instead of $T.fields.len)')
				}
				p.gen(',')
				p.next()
			}
		}
		// Allow `user := User{1,2,3,}`
		// The final comma will be removed by neofmt, since we are not calling `p.fgen()`
		if p.tok == comma {
			p.next()
		}
		if p.tok != right_cbr {
			p.error('too many fields initialized: `$typ` has $T.fields.len field(s)')
		}
	}
	p.gen('}')
	if ptr {
		p.gen(')')
	}
	p.check(right_cbr)
	p.is_struct_init = false
	// println('struct init typ=$typ')
	return typ
}

// `f32(3)`
// tok is `f32` or `)` if `(*int)(ptr)`
fn (p mut Parser) cast(typ string) string {
	// typ := p.lit
	if p.file_path.contains('test') {
		println('CAST TYP=$typ tok=')
		p.print_tok()
	}
	p.gen('($typ)(')
	// p.fgen(typ)
	p.next()
	if p.tok == right_par {
		// skip `)` if it's `(*int)(ptr)`, not `int(a)`
		p.ptr_cast = true
		p.next()
	}
	p.check(left_par)
	p.gen('/*77*/')
	expr_typ := p.bool_expression()
	p.check(right_par)
	p.gen(')')
	if typ == 'string' && expr_typ == 'int' {
		p.error('cannot convert `$expr_typ` to `$typ`')
	}
	return typ
}

fn (p mut Parser) get_tmp() string {
	p.tmp_cnt++
	return 'tmp$p.tmp_cnt'
}

fn (p mut Parser) get_tmp_counter() int {
	p.tmp_cnt++
	return p.tmp_cnt
}

fn os_name_to_ifdef(name string) string { 
	switch name {
		case 'windows': return '_win32'
		case 'mac': return '__apple__'
		case 'linux': return '__linux__' 
	} 
	panic('bad os ifdef name "$name"') 
	return '' 
} 

fn (p mut Parser) comp_time() {
	p.next()
	if p.tok == keyword_if {
		p.next()
		nt := p.tok == not
		if nt {
			p.next()
		}
		name := p.check_name()
		if name in supported_platforms {
			ifdef_name := os_name_to_ifdef(name) 
			if nt {
				p.genln('#ifndef $ifdef_name')
			}
			else {
				p.genln('#ifdef $ifdef_name')
			}
			p.check(left_cbr)
			p.statements_no_curly_end()
			if ! (p.tok == dollar && p.peek() == keyword_else) {
				p.genln('#endif')
			}
		}
		else {
			println('Supported platforms:')
			println(supported_platforms)
			p.error('unknown platform `$name`')
		}
	}
	else if p.tok == keyword_for {
		p.next()
		name := p.check_name()
		if name != 'field' {
			p.error('for field only')
		}
		p.check(keyword_in)
		p.check_name()
		p.check(sdot)
		p.check_name()// fields
		p.check(left_cbr)
		// for p.tok != right_cbr && p.tok != eof {
		res_name := p.check_name()
		println(res_name)
		p.check(sdot)
		p.check(dollar)
		p.check(token_name)
		p.check(assign)
		p.cgen.start_tmp()
		p.bool_expression()
		val := p.cgen.end_tmp()
		println(val)
		p.check(right_cbr)
		// }
	}
	else if p.tok == keyword_else {
		p.next()
		p.check(left_cbr)
		p.genln('#else')
		p.statements_no_curly_end()
		p.genln('#endif')
	}
	else {
		p.error('bad comptime expr')
	}
}

fn (p mut Parser) chash() {
	hashes := p.lit.trim_space()
	// println('chsh() file=$p.file  is_sig=${p.is_sig()} hashes="$hashes"')
	p.next()
	is_sig := p.is_sig()
	if is_sig {
		// p.cgen.nogen = true
	}
	if hashes == 'live' {
		if p.is_so {
			return
		}
		p.is_live = true
		return
	}
	if hashes.starts_with('flag ') {
		mut flag := hashes.right(5)
		// No the right os? Skip!
		// mut ok := true
		if hashes.contains('linux') && p.operating_system != linux {
			return
		}
		else if hashes.contains('darwin') && p.operating_system != mac {
			return
		}
		else if hashes.contains('windows') && p.operating_system != windows {
			return
		}
		// Remove "linux" etc from flag
		if flag.contains('linux') || flag.contains('darwin') || flag.contains('windows') {
			pos := flag.index(' ')
			flag = flag.right(pos)
		}
		flag = flag.trim_space().replace('@NEO', p.neo)
		if p.table.flags.contains(flag) {
			return
		}
		p.log('adding flag "$flag"')
		p.table.flags << flag// .all_after(' '))
		// }
		return
	}
	if hashes.starts_with('include') {
		if p.first_run() && !is_sig {
			p.cgen.includes << '#$hashes'
			return
		}
	}
	else if hashes.starts_with('typedef') {
		if p.first_run() {
			p.cgen.typedefs << '$hashes'
		}
	}
	// TODO remove after ui_mac.m is removed
	else if hashes.contains('embed') {
		pos := hashes.index('embed') + 5
		file := hashes.right(pos)
		if p.build_mode != default_mode {
			p.genln('#include $file')
		}
	}
	else if is_c_pre(hashes) {
		// Skip not current OS hack
		if hashes.starts_with('ifdef') {
			os := hashes.right(6).trim_space()
			// println('ifdef "$os" $p.scanner.line_nr')
			if os == 'linux' && p.operating_system != linux {
				// println('linux ifdef skip')
				for p.tok != eof {
					if p.tok == hash && p.lit.contains('else') || p.lit.contains('endif') {
						break
					}
					// println('skipping')
					p.next()
				}
			}
		}
		// Move defines on top (like old gdefine)
		if hashes.contains('define') {
			p.cgen.includes << '#$hashes'
		}
		else {
			p.genln('#$hashes')
		}
	}
	else {
		if p.cur_fn.name == '' {
			// p.error('#outside of fn')
		}
		p.genln(hashes)
	}
	// p.cgen.nogen = false
	// println('hash=$hashes')
}

fn is_c_pre(hashes string) bool {
	return hashes.contains('ifdef') || hashes.contains('define') ||
	hashes.contains('endif') || hashes.contains('elif') ||
	hashes.contains('ifndef') || (hashes.contains('else') && !hashes.contains('{'))
}

fn (p mut Parser) if_st(is_expr bool) string {
	if is_expr {
		if p.fileis('if_expr') {
			println('keyword_if EXPR')
		}
		p.inside_if_expr = true
		p.gen('(')
	}
	else {
		p.gen('if (')
		p.fgen('if ')
	}
	p.next()
	p.check_types(p.bool_expression(), 'bool')
	if is_expr {
		p.gen(') ? (')
	}
	else {
		p.genln(') {')
		p.fgenln('{')
		p.genln('/*if*/')
	}
	p.fgen(' ')
	p.check(left_cbr)
	mut typ := ''
	// if { if hack
	if p.tok == keyword_if && p.inside_if_expr {
		println('AAAWWFAFAF')
		typ = p.factor()
		println('QWEWQE typ=$typ')
		p.next()
	}
	else {
		typ = p.statements()
	}
	// println('keyword_if TYp=$typ')
	if p.tok == keyword_else {
		p.next()
		if p.tok == keyword_if {
			p.gen(' else ')
			return p.if_st(is_expr)
			// return ''
		}
		if is_expr {
			p.gen(') : (')
		}
		else {
			p.genln(' else { ')
			p.genln('/*else if*/')
		}
		p.check(left_cbr)
		// statements() returns the type of the last statement
		typ = p.statements()
		p.inside_if_expr = false
		if is_expr {
			p.gen(')')
		}
		return typ
	}
	p.inside_if_expr = false
	if p.fileis('test_test') {
		println('if ret typ="$typ" line=$p.scanner.line_nr')
	}
	return typ
}

fn (p mut Parser) for_st() {
	p.check(keyword_for)
	p.fgen(' ')
	p.for_expr_cnt++
	next_tok := p.peek()
	debug := p.scanner.file_path.contains('r_draw')
	if debug {
		println('\n\nFOR {')
	}
	p.cur_fn.open_scope()
	if p.tok == left_cbr {
		// Infinite loop
		p.gen('while (1) {')
	}
	else if p.tok == keyword_mut {
		p.error('`mut` is not required in for loops')
	}
	// for i := 0; i < 10; i++ {
	else if next_tok == decl_assign || next_tok == assign || p.tok == semicolon {
		if debug {
			println('for 1')
		}
		p.genln('for (')
		if next_tok == decl_assign {
			p.var_decl()
		}
		else if p.tok != semicolon {
			// allow `for ;; i++ {`
			// Allow `for i = 0; i < ...`
			p.statement(false)
		}
		if debug {
			println('for 2')
		}
		p.check(semicolon)
		p.gen(' ; ')
		p.fgen(' ')
		if p.tok != semicolon {
			p.bool_expression()
		}
		if debug {
			println('for 3')
		}
		p.check(semicolon)
		p.gen(' ; ')
		p.fgen(' ')
		if p.tok != left_cbr {
			p.statement(false)
		}
		if debug {
			println('for 4')
		}
		p.fgen(' ')
		p.genln(') { ')
	}
	// for i, val in array
	else if p.peek() == comma {
		// for i, val in array { ==>
		// 
		// array_int tmp = array;
		// for (int i = 0; i < tmp.len; i++) {
		// int val = tmp[i];
		i := p.check_name()
		p.check(comma)
		val := p.check_name()
		p.fgen(' ')
		p.check(keyword_in)
		p.fgen(' ')
		tmp := p.get_tmp()
		p.cgen.start_tmp()
		typ := p.bool_expression()
		expr := p.cgen.end_tmp()
		p.genln('$typ $tmp = $expr ;')
		var_typ := typ.right(6)
		// typ = strings.Replace(typ, "_ptr", "*", -1)
		// Register temp var
		val_var := Var {
			name: val
			typ: var_typ
			// parent_fn: p.cur_fn
			ptr: typ.contains('*')
		}
		p.register_var(val_var)
		i_var := Var {
			name: i
			typ: 'int'
			// parent_fn: p.cur_fn
			is_mut: true
		}
		p.register_var(i_var)
		p.genln(';\nfor (int $i = 0; $i < $tmp .len; $i ++) {')
		p.genln('$var_typ $val = (($var_typ *) $tmp . data)[$i];')
	}
	// `for val in vals`
	else if p.peek() == keyword_in {
		val := p.check_name()
		p.fgen(' ')
		p.check(keyword_in)
		p.fspace()
		tmp := p.get_tmp()
		p.cgen.start_tmp()
		typ := p.bool_expression()
		expr := p.cgen.end_tmp()
		// println('if in:')
		// println(p.strtok())
		is_range := p.tok == ddot
		mut range_end := ''
		if is_range {
			p.check_types(typ, 'int')
			p.check_space(ddot)
			p.cgen.start_tmp()
			p.check_types(p.bool_expression(), 'int')
			range_end = p.cgen.end_tmp()
		}
		is_arr := typ.contains('array')
		is_str := typ == 'string'
		// ////if !typ.contains('array') && typ != 'string' {
		if !is_arr && !is_str && !is_range {
			p.error('`for in` requires an array or a string but got `$typ`')
		}
		p.genln('$typ $tmp = $expr;')
		// TODO var_type := if...
		mut var_type := ''
		if is_arr {
			var_type = typ.right(6)// all after `array_`
		}
		else if is_str {
			var_type = 'byte'
		}
		else if is_range {
			var_type = 'int'
		}
		// println('for typ=$typ vartyp=$var_typ')
		// Register temp var
		val_var := Var {
			name: val
			typ: var_type
			ptr: typ.contains('*')
		}
		p.register_var(val_var)
		i := p.get_tmp()
		if is_range {
			p.genln(';\nfor (int $i = $tmp; $i < $range_end; $i++) {')
		}
		else {
			p.genln(';\nfor (int $i = 0; $i < $tmp .len; $i ++) {')
		}
		if is_arr {
			p.genln('$var_type $val = (($var_type *) ${tmp}.data)[$i];')
		}
		else if is_str {
			p.genln('$var_type $val = (($var_type *) ${tmp}.str)[$i];')
		}
		else if is_range {
			p.genln('$var_type $val = $i;')
		}
	}
	else {
		// `for a < b {`
		p.gen('while (')
		p.check_types(p.bool_expression(), 'bool')
		p.genln(') {')
	}
	p.check(left_cbr)
	p.statements()
	p.cur_fn.close_scope()
	p.for_expr_cnt--
}

fn (p mut Parser) switch_statement() {
	p.next()
	p.cgen.start_tmp()
	typ := p.bool_expression()
	expr := p.cgen.end_tmp()
	p.check(left_cbr)
	mut i := 0
	for p.tok == keyword_case || p.tok == keyword_default {
		if p.tok == keyword_default {
			p.genln('else  { // default:')
			p.next()
			p.check(colon)
			p.statements()
			break
		}
		if i > 0 {
			p.gen('else ')
		}
		p.gen('if (')
		// Multiple checks separated by comma
		mut got_comma := false
		for {
			if got_comma {
				p.gen(') ||  ')
			}
			if typ == 'string' {
				p.gen('string_eq($expr, ')
			}
			else {
				p.gen('($expr == ')
			}
			if p.tok == keyword_case || p.tok == keyword_default {
				p.next()
			}
			p.bool_expression()
			if p.tok != comma {
				break
			}
			p.check(comma)
			got_comma = true
		}
		p.check(colon)
		p.gen(')) {')
		p.genln('/* case */')
		p.statements()
		i++
	}
}

fn (p mut Parser) assert_statement() {
	p.check(keyword_assert)
	p.fspace()
	tmp := p.get_tmp()
	p.gen('bool $tmp = ')
	p.check_types(p.bool_expression(), 'bool')
	// TODO print "expected:  got" for failed tests
	filename := p.file_path
	p.genln(';\n 
if (!$tmp) { 
  puts("\\x1B[31mFAILED: $p.cur_fn.name() in $filename:$p.scanner.line_nr\\x1B[0m");  
g_test_ok = 0 ; 
	// TODO
	// Maybe print all vars in a test function if it fails? 
} 
else { 
  puts("\\x1B[32mPASSED: $p.cur_fn.name()\\x1B[0m");
}')
}

fn (p mut Parser) return_st() {
	p.cgen.insert_before(p.cur_fn.defer)
	p.gen('return ')
	if p.cur_fn.name == 'main' {
		p.gen(' 0')
	}
	p.check(keyword_return)
	p.fgen(' ')
	fn_returns := p.cur_fn.typ != 'void'
	if fn_returns {
		if p.tok == right_cbr {
			p.error('`$p.cur_fn.name` needs to return `$p.cur_fn.typ`')
		}
		else {
			ph := p.cgen.add_placeholder()
			expr_type := p.bool_expression()
			// Automatically wrap an object inside an option if the function returns an option
			if p.cur_fn.typ.ends_with(expr_type) && p.cur_fn.typ.starts_with('Option_') {
				p.cgen.set_placeholder(ph, 'opt_ok(& ')
				p.gen(')')
			}
			p.check_types(expr_type, p.cur_fn.typ)
		}
	}
	else {
		// Don't allow `return val` in functions that don't return anything
		// if p.tok != right_cbr && p.tok != hash {
		if false && p.tok == token_name || p.tok == token_int {
			p.error('function `$p.cur_fn.name` does not return a value')
		}
	}
	p.returns = true
}

fn prepend_pkg(pkg, name string) string {
	return '${pkg}__${name}'
}

fn (p &Parser) prepend_pkg(name string) string {
	return prepend_pkg(p.pkg, name)
}

fn (p mut Parser) go_statement() {
	p.check(keyword_go)
	// TODO copypasta of name_expr() ?
	// Method
	if p.peek() == sdot {
		var_name := p.lit
		n := p.cur_fn.find_var(var_name)
		p.cur_fn.mark_var_used(n)
		p.next()
		p.check(sdot)
		typ := p.table.find_type(n.typ)
		mut method := p.table.find_method(typ, p.lit)
		p.async_fn_call(method, 0, var_name, n.typ)
	}
	// Normal function
	else {
		f := p.table.find_fn(p.lit)
		if f.name == 'println' {
			p.error('`go` cannot be used with `println`')
		}
		// println(f.name)
		p.async_fn_call(f, 0, '', '')
	}
}

fn (p mut Parser) register_var(n Var) {
	if n.line_nr == 0 {
		n.line_nr = p.scanner.line_nr
	}
	p.cur_fn.register_var(n)
}

// user:=jsdecode(User, user_json_string)
fn (p mut Parser) js_decode() string {
	p.check(token_name)// json
	p.check(sdot)
	op := p.check_name()
	if op == 'decode' {
		// User tmp2; tmp2.foo = 0; tmp2.bar = 0;// I forgot to zero vals before => huge bug
		// Option_User tmp3 =  jsdecode_User(json_parse( s), &tmp2); ;
		// if (!tmp3 .ok) {
		// return
		// }
		// User u = *(User*) tmp3 . data;  // TODO remove this (generated in or {} block handler)
		p.check(left_par)
		typ := p.get_type()
		p.check(comma)
		p.cgen.start_tmp()
		p.check_types(p.bool_expression(), 'string')
		expr := p.cgen.end_tmp()
		p.check(right_par)
		tmp := p.get_tmp()
		cjson_tmp := p.get_tmp()
		mut decl := '$typ $tmp; '
		// Init the struct
		T := p.table.find_type(typ)
		for field in T.fields {
			def_val := type_default(field.typ)
			if def_val != '' {
				decl += '$tmp . $field.name = $def_val;\n'
			}
		}
		p.gen_json_for_type(T)
		decl += 'cJSON* $cjson_tmp = json__json_parse($expr);'
		p.cgen.insert_before(decl)
		// p.gen('jsdecode_$typ(json_parse($expr), &$tmp);')
		p.gen('json__jsdecode_$typ($cjson_tmp, &$tmp); cJSON_Delete($cjson_tmp);')
		opt_type := 'Option_$typ'
		p.cgen.typedefs << 'typedef Option $opt_type;'
		p.table.register_type(opt_type)
		return opt_type
	}
	else if op == 'encode' {
		p.check(left_par)
		p.cgen.start_tmp()
		typ := p.bool_expression()
		T := p.table.find_type(typ)
		p.gen_json_for_type(T)
		expr := p.cgen.end_tmp()
		p.check(right_par)
		p.gen('json__json_print(json__jsencode_$typ($expr))')
		return 'string'
	}
	else {
		p.error('bad json op "$op"')
	}
	return ''
}

fn is_compile_time_const(s string) bool {
	s = s.trim_space()
	if s == '' {
		return false
	}
	if s.contains('\'') {
		return true
	}
	for c in s {
		if ! ((c >= `0` && c <= `9`) || c == `.`) {
			return false
		}
	}
	return true
}

// fmt helpers
fn (scanner mut Scanner) fgen(s string) {
	if scanner.fmt_line_empty {
		s = repeat_char(`\t`, scanner.fmt_indent) + s
	}
	scanner.fmt_out.write(s)
	scanner.fmt_line_empty = false
}

fn (scanner mut Scanner) fgenln(s string) {
	if scanner.fmt_line_empty {
		s = repeat_char(`\t`, scanner.fmt_indent) + s
	}
	scanner.fmt_out.writeln(s)
	scanner.fmt_line_empty = true
}

fn (p mut Parser) fgen(s string) {
	p.scanner.fgen(s)
}

fn (p mut Parser) fspace() {
	p.fgen(' ')
}

fn (p mut Parser) fgenln(s string) {
	p.scanner.fgenln(s)
}

